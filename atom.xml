<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>QQ空间</title>
  
  <subtitle>一只大帅比</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-06-17T14:19:39.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Dinger</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>h5视频播放的坑以及解决方案</title>
    <link href="http://yoursite.com/2017/06/13/h5%E8%A7%86%E9%A2%91%E6%92%AD%E6%94%BE%E7%9A%84%E5%9D%91%E4%BB%A5%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <id>http://yoursite.com/2017/06/13/h5视频播放的坑以及解决方案/</id>
    <published>2017-06-13T01:38:07.000Z</published>
    <updated>2017-06-17T14:19:39.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近帮朋友做了一个h5活动, 遇到了一堆 video 的问题, 整理一下.</p><h2 id="视频全屏播放"><a href="#视频全屏播放" class="headerlink" title="视频全屏播放"></a>视频全屏播放</h2><h3 id="iOS"><a href="#iOS" class="headerlink" title="iOS"></a>iOS</h3><p>在 iOS 下, video 标签默认是使用系统播放器播放的, 不使用这个播放器的话在 iOS10以下 解决方案有这个<a href="https://github.com/bfred-it/iphone-inline-video" target="_blank" rel="external">inpone-inline-video</a>, iOS10之后只要在 video 标签上添加 webkit-playsinline 属性即可</p><h3 id="安卓"><a href="#安卓" class="headerlink" title="安卓"></a>安卓</h3><p>安卓在这个问题上是个大坑, 首先系统浏览器本身是可以全屏播放的, playsinline 属性, </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近帮朋友做了一个h5活动, 遇到了一堆 video 的问题, 整理一下.&lt;/p&gt;
&lt;h2 id=&quot;视频全屏播放&quot;&gt;&lt;a href=&quot;#视频全屏播放&quot; class=&quot;headerlink&quot; title=&quot;视频全屏播放&quot;&gt;&lt;/a&gt;视频全屏播放&lt;/h2&gt;&lt;h3 id=&quot;iOS&quot;
      
    
    </summary>
    
    
      <category term="html5" scheme="http://yoursite.com/tags/html5/"/>
    
  </entry>
  
  <entry>
    <title>如何调试RxJS(译)</title>
    <link href="http://yoursite.com/2017/05/05/%E5%A6%82%E4%BD%95%E8%B0%83%E8%AF%95RxJS-%E8%AF%91/"/>
    <id>http://yoursite.com/2017/05/05/如何调试RxJS-译/</id>
    <published>2017-05-05T08:53:13.000Z</published>
    <updated>2017-06-07T07:15:51.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://staltz.com/how-to-debug-rxjs-code.html" target="_blank" rel="external">原文How to debug RxJS code</a></p><p>开始学习RxJS时通常都会遇到一个共同的问题, 如何调试RxJS.</p><p>简短一点的答案是: 你需要大量依赖在纸上画Marble Diagram图并且在代码的operators后添加<code>.do(x =&gt; console.log(x))</code></p><p>下面是长答案.<br>一旦你的代码中到处都是Observables并且RxJS订阅了控制流, 传统的断点调试方式就没那么有用了, 你的代码完全使用Observables编码, 断点调试工具对于使用了RxJS库的代码束手无策.</p><p>在责怪RxJS的不可调试之前, 我们先从宏观的角度来看看这个问题. 传统的调试是建立在面向过程的编码方式上的, 而不是其他编程泛型. 你的代码越是面向过程, 传统调试越有用. 使用RxJS的代码比普通的面向过程的js代码更加抽象, 使用传统的调试方式通常并不能帮我们真正解决问题. 同样用于调试Promises或者基于回调函数的代码. 与其说Promise不易调试, 不如直接使用专为Promise设计的调试工具, 比如<a href="https://www.youtube.com/watch?v=o9c3U5_8tGY" target="_blank" rel="external">Chrome的Promise开发者工具</a>(已经被移除)</p><p>这就是说, 当下主要有3种方式调试RxJS:</p><ul><li><a href="#first">添加<code>.do(x =&gt; console.log(x))</code>来追踪log</a></li><li><a href="#second">画依赖图来跟踪据流</a></li><li><a href="#third">画<code>marble diagram</code></a></li></ul><p>调试的目标是使代码在执行过程中我们有一个清晰的思维模型, 下面的这三种技术能够帮我们实现.</p><h2 id="first">追踪log</h2><p>这是最基本的方式: 把事件发生时的数据流传递给<code>console.log</code></p><p>声明一个Observable变量<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> shortLowerCaseName$ = name$</span><br><span class="line">.map(name =&gt; name.toLowerCase())</span><br><span class="line">.filter(name =&gt; name.length &lt; <span class="number">5</span>)</span><br></pre></td></tr></table></figure></p><p>数据有两次变换, 我们可以在两次operators之间插入<code>.do(x =&gt; console.log(x))</code><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> shortLowerCaseName$ = name$</span><br><span class="line">.map(name =&gt; name.toLowerCase())</span><br><span class="line">.do(x =&gt; <span class="built_in">console</span>.log(x))</span><br><span class="line">.filter(name =&gt; name.length &lt; <span class="number">5</span>);</span><br></pre></td></tr></table></figure></p><p><code>do</code>就像一次什么都没有做的map操作一样, 上面的代码等价于:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> shortLowerCaseName$ = name$</span><br><span class="line">.map(name =&gt; name.toLowerCase())</span><br><span class="line">.map(x =&gt; &#123;</span><br><span class="line"><span class="built_in">console</span>.log(x);</span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">&#125;)</span><br><span class="line">.filter(name =&gt; name.length &lt; <span class="number">5</span>);</span><br></pre></td></tr></table></figure></p><p>和直接订阅<code>shortLowerCaseName$</code>不同<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> shortLowerCaseName$ = name$</span><br><span class="line">.map(name =&gt; name.toLowerCase())</span><br><span class="line">.filter(name =&gt; name.length &lt; <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">shortLowerCaseName$.subscribe(name =&gt; <span class="built_in">console</span>.log(x));</span><br></pre></td></tr></table></figure></p><p>因为Observables在订阅之前是不会执行的(类似于generator), 订阅会触发operator的链式执行, 如果在<code>do</code>中使用了<code>log</code>但是没有订阅, <code>console.log</code>永远都不会执行.</p><p>所以<code>.do(x =&gt; console.log(x))</code>是一种无侵入的追踪技术, 不会改变代码本身的行为, 只是简单的反应中实际执行过程中的情况, 而订阅是侵入式的, 因为它会向operator链请求数据, 改变代码本身的运行, 特别是在调试.</p><p>注意<code>do()</code>也是一个operator: 它会返回一个新的Observable. 如果你只是想简单的用<code>do()</code>替换<code>subscribe()</code>, 没什么卵用, 因为你只能获取一个新的Observable但是并没有拉取数据.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> shortLowerCaseName$ = name$</span><br><span class="line">.map(name =&gt; name.toLowerCase())</span><br><span class="line">.filter(name =&gt; name.length &lt; <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// This console.log will never happen!</span></span><br><span class="line">shortLowerCaseName$.<span class="keyword">do</span>(name =&gt; <span class="built_in">console</span>.log(name));</span><br></pre></td></tr></table></figure><p>想要获取<code>do()</code>的输出必须把它放在operator链中并且最后订阅数据流.</p><h2 id="second">画依赖图来跟踪数据</h2><p>假如有如下的代码:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> shortLowerCaseName$ = name$</span><br><span class="line">.map(name =&gt; name.toLowerCase())</span><br><span class="line">.filter(name =&gt; name.length &lt; <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bmi$ = weight$.combineLatest(height$, (weight, height) =&gt;</span><br><span class="line"><span class="built_in">Math</span>.round(weight / (height * height * <span class="number">0.0001</span>))</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fullInfo$ = shortLowerCaseName$.combineLatest(bmi$);</span><br></pre></td></tr></table></figure><p>我们顺着依赖关系(例如: shortLowerCaseName$ 依赖于 name$)可以建立依赖关系图, 如下:</p><p><img src="https://staltz.com/img/debugging-dep-graph.png" alt=""></p><p>简单分析代码之后我们可以很容易的画出来这个图. 每个圈是一个Observable, 并且每个变量声明<code>var b$ = a$.flatMap(...)</code> 在图上就是一个箭头 <code>a$ --&gt; b$</code></p><p>Observable的依赖图应该是我们想到的第一个调试工具来检查代码中是否有bug, 对代码结构来说是非常有用的概括.<br>如果在纸上画出依赖图, 你可以在代码的关键位置添加<code>.do(x =&gt; console.log(x))</code>, 来检查Observable每一次操作的情况. 接下来代码执行时你可以通过依赖图看到数据流是如何传递的.</p><p>(冷信号, 每次订阅都从头开始, 没有状态, 热信号是所有的订阅者共享信号的状态)<br>要时刻清楚的意识到依赖图中的Observable也是有冷热的, 例如, $a有两个输出箭头, a$ –&gt; b$ 和 a$ –&gt; c$, a$可能使用了.share()变成了b$和c$的热信号. 尽管有时a$需要是个冷信号, 但是我们应该时刻清楚的判断一个信号到底是冷还是热.</p><p>通常依赖图已经足够指出数据流中的哪部分和我们所期望的不一致, 进一步的, 我们可以针对某个Observable放大来看, 使用marble diagram来调试它.</p><h2 id="third">画<code>marble diagram</code></h2><p>大部分基础的RxJS的操作都有<a href="http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#instance-method-map" target="_blank" rel="external">marble diagrams</a>, marble diagram把一个operator操作的Observable的输入(带点的箭头, 在上面)和输出(带点的箭头, 在下面)用图表示出来, 来解释operator是如何工作的. 因为operator只是一个返回新的Observable的函数, 所以你也可以绘制任何输入一个Observables输出一个Observable的函数.</p><p><img src="http://reactivex.io/rxjs/img/map.png" alt=""></p><p>如果你不确定某个operator是如何运行的, 在这个operator的前后添加<code>.do(x =&gt; console.log(x))</code>, 然后执行代码, 绘制marble diagram, 然后很快就可以知道这个operator是如何工作了. 使用<a href="http://rxmarbles.com/" target="_blank" rel="external">RxMarbles</a>, 拖动marbles来查看基础的operator是如何创建输出的Observable.</p><h2 id="未来"><a href="#未来" class="headerlink" title="未来"></a>未来</h2><p>如介绍中所说, 传统的调试在调试RxJS时并没有多大卵用, 并且你可能已经见过了在RxJS库中巨大的函数调用栈.</p><p>在下个版本(现在已经是了)会有大幅改进, 调用栈会浅很多, 来使传统方式调试RxJS代码变的可以忍受. </p><p>像Promise得到了专有的调试工具(又没了…), RxJS的Observables也可以有专有的调试工具.<br>注入行为到operator链上的所有的观察者, 来自Netflix公司的Ben Lesh 提到未来计划开发一个基于<code>lift()</code>的RxJS调试工具.</p><p>在不远的将来, 我们可能会看到实时渲染的依赖关系图或者实时的marble diagrams. 前者可能是使用静态分析或者使用lift架构.</p><p>在RxJS5的单元测试中, 大面积的使用marble diagrams(文本格式), 例如:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">it.asDiagram(<span class="string">'debounce'</span>)(<span class="string">'should debounce events'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">var</span> e1 =   hot(<span class="string">'-a--bc--d---|'</span>);</span><br><span class="line">  <span class="keyword">var</span> e2 =  cold( <span class="string">'--|         '</span>);</span><br><span class="line">  <span class="keyword">var</span> expected = <span class="string">'---a---c--d-|'</span>;</span><br><span class="line">  <span class="keyword">var</span> result = e1.debounce(() =&gt; e2);</span><br><span class="line">  expectObservable(result).toBe(expected);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这些基于文本的marble diagrams已经有用户在RxJS5中使用. 而且, PNG图也可以自动生成. 上述代码的PNG图如下:</p><p><img src="https://staltz.com/img/debounce.png" alt=""></p><p>自动静态分析这些marble diagrams是自动渲染的第一步.</p><p>RxJS的调试工具依然很薄弱, 但是我们正在付出巨大的努力来获得强大的适合Observables的工具</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://staltz.com/how-to-debug-rxjs-code.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;原文How to debug RxJS code&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;开始学习RxJS时通常都会
      
    
    </summary>
    
    
      <category term="rxjs" scheme="http://yoursite.com/tags/rxjs/"/>
    
  </entry>
  
  <entry>
    <title>命令行神器</title>
    <link href="http://yoursite.com/2017/05/05/%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%A5%9E%E5%99%A8/"/>
    <id>http://yoursite.com/2017/05/05/命令行神器/</id>
    <published>2017-05-05T00:47:37.000Z</published>
    <updated>2017-06-07T07:15:51.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="thefuck"><a href="#thefuck" class="headerlink" title="thefuck"></a>thefuck</h2><p>mac直接使用homebrew安装<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install thefuck</span><br></pre></td></tr></table></figure></p><p>编辑.zshrc文件, 将以下代码插入最后<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">eval</span> <span class="string">"<span class="variable">$(thefuck --alias)</span>"</span></span><br></pre></td></tr></table></figure></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> .zshrc</span><br></pre></td></tr></table></figure><p>使用<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ pythan</span><br><span class="line">zsh: <span class="built_in">command</span> not found: pythan</span><br><span class="line">➜  ~ fuck</span><br><span class="line">python [enter/↑/↓/ctrl+c]</span><br></pre></td></tr></table></figure></p><h2 id="cloc"><a href="#cloc" class="headerlink" title="cloc"></a>cloc</h2><p>统计代码语言, 空行数, 注释数<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install cloc</span><br></pre></td></tr></table></figure></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ cloc xx.py</span><br><span class="line">    1 text file.</span><br><span class="line">    1 unique file.</span><br><span class="line">    0 files ignored.</span><br><span class="line"></span><br><span class="line">github.com/AlDanial/cloc v 1.72  T=0.04 s (22.3 files/s, 2346.2 lines/s)</span><br><span class="line">-------------------------------------------------------------------------------</span><br><span class="line">Language                     files          blank        comment           code</span><br><span class="line">-------------------------------------------------------------------------------</span><br><span class="line">Python                           1             28              2             75</span><br><span class="line">-------------------------------------------------------------------------------</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;thefuck&quot;&gt;&lt;a href=&quot;#thefuck&quot; class=&quot;headerlink&quot; title=&quot;thefuck&quot;&gt;&lt;/a&gt;thefuck&lt;/h2&gt;&lt;p&gt;mac直接使用homebrew安装&lt;br&gt;&lt;figure class=&quot;highlight bash
      
    
    </summary>
    
    
      <category term="zsh" scheme="http://yoursite.com/tags/zsh/"/>
    
  </entry>
  
  <entry>
    <title>评论添加网易云跟帖</title>
    <link href="http://yoursite.com/2017/04/27/%E8%AF%84%E8%AE%BA%E6%B7%BB%E5%8A%A0%E7%BD%91%E6%98%93%E4%BA%91%E8%B7%9F%E5%B8%96/"/>
    <id>http://yoursite.com/2017/04/27/评论添加网易云跟帖/</id>
    <published>2017-04-27T08:41:07.000Z</published>
    <updated>2017-06-07T07:15:51.000Z</updated>
    
    <content type="html"><![CDATA[<p>多说即将关闭(不过一直没用), 偶然看到了网易推出了云跟帖服务, 搞了一下, 首先配置完主观的评价一下, 和其他的产品相比优点暂时没看到, 列几个缺点:</p><ul><li>站点配置不支持二级域名, 好多同学应该都使用github的pages服务, github.io的域名暂时在这里是不支持的, 而且在配置出错时不直接显示原因, <code>站名名称或者url已经存在</code>, 后来搞了个CNAME终于配置成功</li><li>文档里没什么有价值的东西, 官网下有站长qq群, 然而加了一天也没有回复, 不知道是不是rp的问题</li><li>官方可以设置回推接口, 即有评论后向指定url推送</li></ul><p><img src="http://7xr09w.com1.z0.glb.clouddn.com/42DA6473-ECC1-4313-9A7E-C11C94303B45.png" alt=""></p><p>文档里是这样写的</p><p> <img src="http://7xr09w.com1.z0.glb.clouddn.com/C4C2D958-89AF-4B94-8DAC-4086EE74D9F7.png" alt=""></p><p>哦是一个数组啊, 那我知道了, 还不确定是以<code>text/json</code>的形式还是<code>application/x-www-form-urlencoded</code>提交的, 两种方式都尝试没有正确答案<br>其实真实的数据是<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">"data"</span>:<span class="string">"[&#123;"</span>title<span class="string">":"</span>u4e91u8ddfu8d34u4f53u9a8cu6587u7ae0<span class="string">","</span>url<span class="string">":"</span>http://rasca1xsss<span class="string">","</span>sourceId<span class="string">":"</span><span class="number">2</span><span class="string">","</span>ctime<span class="string">":1461333601000,"</span>comments<span class="string">":[&#123;"</span>cid<span class="string">":"</span><span class="number">2555053846</span><span class="string">","</span>content<span class="string">":"</span>u6765u81eau4e91u8ddfu8d34u7684u6d4bu8bd5u6570u636e<span class="string">","</span>ctime<span class="string">":1471252987000,"</span>pid<span class="string">":"</span><span class="number">0</span><span class="string">","</span>ip<span class="string">":"</span><span class="number">220.181</span><span class="number">.102</span><span class="number">.177</span><span class="string">","</span>source<span class="string">":"</span>web<span class="string">","</span>anonymous<span class="string">":false,"</span>attachment<span class="string">":&#123;"</span>type<span class="string">":0,"</span>desc<span class="string">":"</span><span class="string">","</span>info<span class="string">":"</span><span class="string">"&#125;,"</span>user<span class="string">":&#123;"</span>userId<span class="string">":"</span><span class="number">95738681</span><span class="string">","</span>nickname<span class="string">":"</span>u7f51u6613u4e91u8ddfu8d34u5b98u65b9<span class="string">","</span>avatar<span class="string">":"</span>http://cms-bucket.nosdn<span class="number">.127</span>.net/ec18d69788bb43aa866884633d212df720161220225628.jpg<span class="string">"&#125;&#125;]&#125;]"</span>&#125;</span><br></pre></td></tr></table></figure></p><p>妈的前面的data让你吃了啊!!!</p><p>在主题中添加支持就比较简单了, 我使用的主题用的<code>jade</code>模板, 当然<code>ejs</code>, <code>swig</code>也没多大区别, 换换语法就可以了</p><p><img src="http://7xr09w.com1.z0.glb.clouddn.com/DF563CE9-F79C-418F-BD85-10F13C0CC322.png" alt=""></p><p>这里的<code>post.jade</code>是文章页的模板, 一般评论都是放在文末的, 找到这里有一句<code>include partial/comment</code>,</p><p><img src="http://7xr09w.com1.z0.glb.clouddn.com/9A05779C-CD38-4504-8AC6-7D80D54FC9CA.png" alt=""></p><p> 即使不懂jade语法也知道了这里引入了评论的部分, 找到对应文件</p><p><img src="http://7xr09w.com1.z0.glb.clouddn.com/2892E225-5A13-4F9C-AC8C-25145A921086.png" alt=""></p><p>可以看到分别有多说和disqus的布局结构, 把网易的对应的结构加上, 然后去修改js</p><p>模板中预先准备了多说和disqus的脚本, 在后面加一段网易的代码(在官方后台管理的获取代码位置可以获得)</p><p><img src="http://7xr09w.com1.z0.glb.clouddn.com/F9DEF3A2-B721-4B86-96C3-C298B8B4784B.png" alt=""></p><p>结束!</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;多说即将关闭(不过一直没用), 偶然看到了网易推出了云跟帖服务, 搞了一下, 首先配置完主观的评价一下, 和其他的产品相比优点暂时没看到, 列几个缺点:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;站点配置不支持二级域名, 好多同学应该都使用github的pages服务, github.io
      
    
    </summary>
    
    
      <category term="hexo" scheme="http://yoursite.com/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>关于柯里化以及反柯里化</title>
    <link href="http://yoursite.com/2017/03/20/%E5%85%B3%E4%BA%8E%E6%9F%AF%E9%87%8C%E5%8C%96%E4%BB%A5%E5%8F%8A%E5%8F%8D%E6%9F%AF%E9%87%8C%E5%8C%96/"/>
    <id>http://yoursite.com/2017/03/20/关于柯里化以及反柯里化/</id>
    <published>2017-03-20T01:29:07.000Z</published>
    <updated>2017-06-07T07:15:51.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、柯里化-curring"><a href="#一、柯里化-curring" class="headerlink" title="一、柯里化(curring)"></a>一、柯里化(curring)</h2><p>在<a href="https://zh.wikipedia.org/wiki/%E6%9F%AF%E9%87%8C%E5%8C%96" target="_blank" rel="external">维基百科</a>上的解释是: 把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的新函数的技术。</p><a id="more"></a><p>柯里化的概念简单来说就是把常见的多参数函数改为分步调用, ,逐步传参, 逐步缩小范围, 简单举例</p><p>js的写法<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> result = add(<span class="number">1</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure></p><p>这是传统方式的写法, 柯里化之后<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">num1</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">num2</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> num1 + num2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> result = add(<span class="number">1</span>)(<span class="number">2</span>);</span><br></pre></td></tr></table></figure></p><p>py的写法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">inc</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">incx</span><span class="params">(y)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> x+y</span><br><span class="line">    <span class="keyword">return</span> incx</span><br><span class="line"></span><br><span class="line">inc2 = inc(<span class="number">2</span>)</span><br><span class="line">inc5 = inc(<span class="number">5</span>)</span><br><span class="line"><span class="keyword">print</span> inc2(<span class="number">5</span>)</span><br><span class="line"><span class="keyword">print</span> inc5(<span class="number">5</span>)</span><br></pre></td></tr></table></figure><p>黑人问号脸, 有什么卵用???<br>换个喵神在<a href="http://swifter.tips/currying/" target="_blank" rel="external">swift tips</a>中举的例子, 翻译成js</p><blockquote><p>柯里化是一种量产相似方法的好办法, 可以通过柯里化一个方法模板来避免写出很多重复代码, 也方便今后维护<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">greaterThan</span>(<span class="params">comparer</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> num &gt; comparer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> greaterThan10 = greaterThan(<span class="number">10</span>);</span><br><span class="line">greaterThan10(<span class="number">13</span>) <span class="comment">//true</span></span><br><span class="line">greaterThan10(<span class="number">8</span>)  <span class="comment">//false</span></span><br></pre></td></tr></table></figure></p></blockquote><p>有点工厂模式的味道. </p><p>再举一个比较常见, 而且比较重要的例子, bind函数的实现<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;.bind) &#123;</span><br><span class="line">    <span class="built_in">Function</span>.prototype.bind = <span class="function"><span class="keyword">function</span>(<span class="params">context</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> self = <span class="keyword">this</span>, args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> self.apply(context, args.slice(<span class="number">1</span>));    </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>另外关于这个函数还可以换方式写, 考察对arguments, apply/call的理解, 也挺有意思的<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;.bind) &#123;</span><br><span class="line">    <span class="built_in">Function</span>.prototype.bind = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> self = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">var</span> context = [].shift.call(<span class="built_in">arguments</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> self.apply(context, <span class="built_in">arguments</span>);    </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>关于柯里化的具体作用也存在争议, 有其优点也有缺陷, 因此只有用在正确的地方才是生产力的提升(废话), apple在swift2中添加了原生柯里化的支持, 即函数可以这么写<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(num1: Int)</span></span>(num2: <span class="type">Int</span>) -&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> num1 + num2</span><br><span class="line">&#125;</span><br><span class="line">add(<span class="number">1</span>)(<span class="number">2</span>)</span><br></pre></td></tr></table></figure></p><p>然而在swift3中又去掉了这种方式, 官方的<a href="https://github.com/apple/swift-evolution/blob/master/proposals/0002-remove-currying.md" target="_blank" rel="external">解释</a>是用处有限, 实现复杂</p><blockquote><p>(Curried function declaration syntax func <code>foo(x: Int)(y: Int)</code> is of limited usefulness and creates a lot of language and implementation complexity. We should remove it.)</p></blockquote><h2 id="二、反柯里化-uncurring"><a href="#二、反柯里化-uncurring" class="headerlink" title="二、反柯里化(uncurring)"></a>二、反柯里化(uncurring)</h2><p>反柯里化的作用是，当我们调用某个方法，不用考虑这个对象在被设计时，是否拥有这个方法，只要这个方法适用于它，我们就可以对这个对象使用它。<br>到这里都要提一下<a href="https://zh.wikipedia.org/zh-hans/%E9%B8%AD%E5%AD%90%E7%B1%BB%E5%9E%8B" target="_blank" rel="external">鸭子类型</a>(duck typing)</p><blockquote><p>“当看到一只鸟走起来像鸭子、游泳起来像鸭子、叫起来也像鸭子，那么这只鸟就可以被称为鸭子。</p></blockquote><p>第一次看到这个概念的时候先想到的是OC里的id类型, id类型的对象可以接受任何方法, 被当做鸭子来测试, 在js中, 提供了call/apply的接口方便我们用类似的思想解决问题.</p><p>在js中有一种奇葩类型, 比如arguments, 这是一个类数组的对象, 其本质是个object, 因此没有数组身上的push/pop之类的方法, 然而在某些时候他也需要这些方法, 比如上面用到的<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[].shift.call(<span class="built_in">arguments</span>);</span><br></pre></td></tr></table></figure></p><p>通过call/apply的方式可以方便的让其他类型的对象调用自身没有的方法, 反柯里化的实现<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.uncurrying = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> self = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">Function</span>.prototype.call.apply(self, <span class="built_in">arguments</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//测试</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    length: <span class="number">1</span>,</span><br><span class="line">    <span class="number">0</span>: <span class="string">"a"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> push = [].push.uncurrying();</span><br><span class="line">push(obj, <span class="string">"b"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(obj); <span class="comment">//&#123; '0': 'a', '1': 'b', length: 2 &#125;</span></span><br></pre></td></tr></table></figure></p><p>最后的函数调用有种php原生函数的感觉, 把调用方法的对象作为参数传入.</p><p>下面这种写法可能更容易理解一些<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.uncurring = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> self = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">var</span> obj = [].shift.call(<span class="built_in">arguments</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        self.apply(obj, <span class="built_in">arguments</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、柯里化-curring&quot;&gt;&lt;a href=&quot;#一、柯里化-curring&quot; class=&quot;headerlink&quot; title=&quot;一、柯里化(curring)&quot;&gt;&lt;/a&gt;一、柯里化(curring)&lt;/h2&gt;&lt;p&gt;在&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E6%9F%AF%E9%87%8C%E5%8C%96&quot;&gt;维基百科&lt;/a&gt;上的解释是: 把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的新函数的技术。&lt;/p&gt;
    
    </summary>
    
    
      <category term="javascript swift" scheme="http://yoursite.com/tags/javascript-swift/"/>
    
  </entry>
  
  <entry>
    <title>linux下安装git遇到的小坑</title>
    <link href="http://yoursite.com/2016/09/29/linux%E4%B8%8B%E5%AE%89%E8%A3%85git%E9%81%87%E5%88%B0%E7%9A%84%E5%B0%8F%E5%9D%91/"/>
    <id>http://yoursite.com/2016/09/29/linux下安装git遇到的小坑/</id>
    <published>2016-09-29T06:10:01.000Z</published>
    <updated>2017-06-07T07:15:51.000Z</updated>
    
    <content type="html"><![CDATA[<p>前几天买了个<a href="bwh1.net">搬瓦工</a>的服务器, 做ss的备用, 为了方便装了<a href="http://www.wdlinux.cn/wdcp/" target="_blank" rel="external">WDCP</a>做web服务器的集成环境, 考虑用github的webhook来同步代码, 所以需要在linux下装git.<br> 使用yum工具, 使用方式和mac下的homebrew类似, 包管理器, 可以方便的安装各种软件, 并且自动安装依赖包.</p>  <a id="more"></a><p>在使用</p><pre><code>yum install git-core</code></pre><p>结果</p><pre><code>Error: Cannot retrieve repository metadata (repomd.xml) for repository: RPMForge. Please verify its path and try again</code></pre><p>RPMForge是一个软件库, 可能是找不到这个包的路径, 然后找到了把这个包的源改成国内<a href="http://mirrors.163.com/.help/centos.html" target="_blank" rel="external">网易源</a>的方法</p><pre><code># wget http://mirrors.163.com/.help/CentOS6-Base-163.repo -O /etc/yum.repos.d/CentOS-Base.repo# yum makecache</code></pre><p>我的系统是CentOS-6, 如果是CentOS-5的话把链接里的6改成5即可, 安装之后可以查看<code>/etc/yum.repos.d/rpmforge.repo</code>文件中的配置</p><pre><code># CentOS-Base.repo## The mirror system uses the connecting IP address of the client and the# update status of each mirror to pick mirrors that are updated to and# geographically close to the client.  You should use this for CentOS updates# unless you are manually picking other mirrors.## If the mirrorlist= does not work for you, as a fall back you can try the# remarked out baseurl= line instead.##[base]name=CentOS-$releasever - Base - 163.combaseurl=http://mirrors.163.com/centos/$releasever/os/$basearch/#mirrorlist=http://mirrorlist.centos.org/?release=$releasever&amp;arch=$basearch&amp;repo=osgpgcheck=1gpgkey=http://mirror.centos.org/centos/RPM-GPG-KEY-CentOS-6#released updates[updates]name=CentOS-$releasever - Updates - 163.combaseurl=http://mirrors.163.com/centos/$releasever/updates/$basearch/#mirrorlist=http://mirrorlist.centos.org/?release=$releasever&amp;arch=$basearch&amp;repo=updatesgpgcheck=1gpgkey=http://mirror.centos.org/centos/RPM-GPG-KEY-CentOS-6#additional packages that may be useful[extras]name=CentOS-$releasever - Extras - 163.combaseurl=http://mirrors.163.com/centos/$releasever/extras/$basearch/#mirrorlist=http://mirrorlist.centos.org/?release=$releasever&amp;arch=$basearch&amp;repo=extrasgpgcheck=1gpgkey=http://mirror.centos.org/centos/RPM-GPG-KEY-CentOS-6#additional packages that extend functionality of existing packages[centosplus]name=CentOS-$releasever - Plus - 163.combaseurl=http://mirrors.163.com/centos/$releasever/centosplus/$basearch/#mirrorlist=http://mirrorlist.centos.org/?release=$releasever&amp;arch=$basearch&amp;repo=centosplusgpgcheck=1enabled=0gpgkey=http://mirror.centos.org/centos/RPM-GPG-KEY-CentOS-6#contrib - packages by Centos Users[contrib]name=CentOS-$releasever - Contrib - 163.combaseurl=http://mirrors.163.com/centos/$releasever/contrib/$basearch/#mirrorlist=http://mirrorlist.centos.org/?release=$releasever&amp;arch=$basearch&amp;repo=contribgpgcheck=1enabled=0gpgkey=http://mirror.centos.org/centos/RPM-GPG-KEY-CentOS-6</code></pre><p>修改之后又需要下一个问题</p><pre><code>initscripts-9.03.46-1.el6.centos.1.i686 has missing requires of udev &gt;= (&apos;0&apos;, &apos;125&apos;, &apos;1&apos;)util-linux-ng-2.17.2-12.18.el6.i686 has missing requires of udevvzdev-1.0-7.swsoft.noarch has missing requires of udev</code></pre><p>可以看出是缺少了udev, 所以</p><pre><code>yum install udev</code></pre><p>安装成功之后又到了下一个坑里</p><pre><code>错误：Package: git-1.7.12.4-1.el5.rf.i386 (rpmforge)          Requires: libcurl.so.3 You could try using --skip-broken to work around the problem You could try running: rpm -Va --nofiles --nodigest</code></pre><p>google找到CentOS官网的一个<a href="https://www.centos.org/forums/viewtopic.php?t=5028" target="_blank" rel="external">问题</a>, 大神一语道破</p><blockquote><p>The package that you are installing now comes from one of those and is pulling in the libcurl-devel from the other repo when it expects to find the one from the same repo as itself.</p></blockquote><p>可能是从RPMForge安装的包使用了CentOS-Base中的依赖库, 建议使用yum-priorities插件来管理安装时选择仓库的顺序, 这个插件用来保证安装软件时候软件仓库先后次序（priority优先权），一般是默认先从官方base或者镜像安装，然后从社区用户contribute的软件中安装，再从第三方软件仓库中安装。当然这个次序可以自己更改，为了安全和稳定还是依照这个次序吧。</p><ol><li><p>安装priorities插件</p><pre><code>yum install yum-priorities</code></pre></li><li><p>确认插件开启<br> 查看/etc/yum/pluginconf.d/priorities.conf文件, 确认文件中<code>enabled=1</code>.</p></li><li><p>设置默认仓库优先级<br> 在/etc/yum.repos.d/CentOS-Base.repo文件中, [base]、[updates]、[addons]、[extras]最后分别设置priority=1，[centosplus]、[contrib]最后分别设置priority=2，其他第三的软件源设置priority=N（推荐N&gt;10）。</p></li><li><p>设置优先级<br> 设置/etc/yum.repos.d/rpmforge.repo文件, [rpmforge]、[rpmforge-extras]、[rpmforge-testing]最后分别设置priority=11.</p></li></ol><p>终于, 最后看见了</p><pre><code>已安装:  git.i686 0:1.7.1-4.el6_7.1作为依赖被安装:  perl-Error.noarch 1:0.17015-4.el6                  perl-Git.noarch 0:1.7.1-4.el6_7.1完毕！</code></pre><p>参考资料:<br><a href="http://www.live-in.org/archives/998.html" target="_blank" rel="external">http://www.live-in.org/archives/998.html</a><br><a href="https://www.centos.org/forums/viewtopic.php?t=5028" target="_blank" rel="external">https://www.centos.org/forums/viewtopic.php?t=5028</a><br><a href="http://www.dabu.info/centos-163-source-and-automatically-match-the-source-plug-yum-fastestmirror.html" target="_blank" rel="external">http://www.dabu.info/centos-163-source-and-automatically-match-the-source-plug-yum-fastestmirror.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前几天买了个&lt;a href=&quot;bwh1.net&quot;&gt;搬瓦工&lt;/a&gt;的服务器, 做ss的备用, 为了方便装了&lt;a href=&quot;http://www.wdlinux.cn/wdcp/&quot;&gt;WDCP&lt;/a&gt;做web服务器的集成环境, 考虑用github的webhook来同步代码, 所以需要在linux下装git.&lt;br&gt; 使用yum工具, 使用方式和mac下的homebrew类似, 包管理器, 可以方便的安装各种软件, 并且自动安装依赖包.&lt;/p&gt;
    
    </summary>
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>php路由机制的实现</title>
    <link href="http://yoursite.com/2016/09/19/htaccess%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2016/09/19/htaccess文件详解/</id>
    <published>2016-09-19T01:36:33.000Z</published>
    <updated>2017-06-07T07:15:51.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h2><p><strong>维基百科</strong>路由（routing）就是通过互联的网络把信息从源地址传输到目的地址的活动。路由发生在OSI网络参考模型中的第三层即网路层。路由引导分组转送，经过一些中间的节点后，到它们最后的目的地。作成硬件的话，则称为路由器。<br>在php中的路由同OSI中路由的作用相似, 用来处理接收到的请求，将请求指向相应的控制器或者处理程序.</p><a id="more"></a><h2 id="为什么"><a href="#为什么" class="headerlink" title="为什么"></a>为什么</h2><p>在我们见到的大多数网站的url里, 都会有对路径的指示, 比如这种</p><pre><code>https://www.google.com/search?q=html&amp;oq=html&amp;aqs=chrome.0.69i59j69i60l3j69i57j69i60.596j0j4&amp;sourceid=chrome&amp;ie=UTF-8</code></pre><p>或者</p><pre><code>https://developer.mozilla.org/en-US/docs/Web/HTML/Element/address</code></pre><p>第一种url内容比较长而且不易读, 第二种url用户或者搜索引擎可以直接读取到有用的内容, 通过这种url, 爬虫可以方便的通过处理url(通过’/‘分割)来对内容进行分类.要让服务器理解第二种url并返回正确的数据的话, 需要对服务器进行相应的配置. </p><h2 id="怎样做"><a href="#怎样做" class="headerlink" title="怎样做"></a>怎样做</h2><ul><li>工具 <strong>.htacess</strong></li></ul><blockquote><p><strong>百度百科</strong>.htaccess文件(或者”分布式配置文件”）提供了针对目录改变配置的方法， 即，在一个特定的文档目录中放置一个包含一个或多个指令的文件， 以作用于此目录及其所有子目录。作为用户，所能使用的命令受到限制。管理员可以通过Apache的AllowOverride指令来设置。</p><p><strong>维基百科</strong>.htaccess 是Apache HTTP Server的文件目录系统级别的配置文件的默认的名字。它提供了在主配置文件中定义用户自定义指令的支持。 这些配置指令需要在 .htaccess 上下文 和用户需要的适当许可。</p></blockquote><p>通过.htaccess可以实现url的重定向, 伪静态, 设置错误页面, 限制ip访问等等功能.<br>在服务器根目录(或者单独需要路由规则的目录下)创建文件, 文件名.htaccess, 在这个文件中用#注释.</p><ol><li>设置目录的默认页面<figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#设置默认页面</span></span><br><span class="line">DirectoryIndex <span class="keyword">index</span>.html <span class="keyword">index</span>.PHP <span class="keyword">index</span>.htm</span><br></pre></td></tr></table></figure></li></ol><p>打开目录时默认打开index.html文件</p><ol><li>设置错误页面<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute"><span class="nomarkup">ErrorDocument</span></span> 404 404.html</span><br></pre></td></tr></table></figure></li></ol><p>自定义错误页面, 规则是ErrorDocument 错误码 错误页</p><ol><li>重定向<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#开启Rewrite</span></span><br><span class="line"><span class="attribute"><span class="nomarkup">RewriteEngine</span></span> <span class="literal">on</span></span><br><span class="line"><span class="comment">#默认为/, 即根目录, 在根目录下不需要设置</span></span><br><span class="line"><span class="attribute">RewriteBase</span> /MVC/</span><br></pre></td></tr></table></figure></li></ol><p>Rewirte主要的功能就是实现URL的跳转和隐藏真实地址, 通过正则表达式将匹配到的URL重定向到对应的文件中</p><p>比如要将url</p><pre><code>http://www.xx.com/api.php?type=detail&amp;id=123</code></pre><p>跳转至</p><pre><code>http://www.xx.com/detail/123</code></pre><p>Rewrite代码为</p><pre><code>RewriteRule ^([a-zA-Z0-9]+)/([0-9]+)$ api.php?type=$1&amp;id=$2#$1和$2为正则表达式中通过小括号取到的子表达式</code></pre><p>Rewirte模块内部处理</p><p>Rewirte模块的内部处理极为复杂，但是为了使一般用户避免犯低级错误，也让管理员能充分利用其功能，在此仍然做一下说明。</p><p>Rewirte模块API阶段</p><p>首先，你必须了解Apache是分若干阶段来处理HTTP请求的。Apache API对每个阶段都提供了一个hook程序。mod_rewrite使用两个hook程序：其一，从URL到文件名的转换hook(用在读取HTTP请求之后、授权开始之前)； 其二，修正hook(用在授权阶段和读取目录级配置(.htaccess)之后、内容处理器激活之前)。</p><p>所以，Apache收到一个请求并且确定了响应主机(或虚拟主机)之后，重写引擎即开始处理服务器级配置中的所有mod_rewrite指令(此时处于从URL到文件名转换的阶段)，此阶段完成后，最终的数据目录便确定了。接下来进入修正程序段并触发目录级配置中的mod_rewrite指令。这两个阶段并不是泾渭分明的，但都实施了把URL重写成新的URL或者文件名。虽然API最初不是为此目的而设计的，但是现在它已经成为了API的一种用途。记住以下两点，会有助于更好地理解：</p><p>1、虽然mod_rewrite可以将URL重写为新的URL或文件名，甚至将文件名重写为新的文件名，但是之前的API只提供从URL到文件名的hook。在Apache 2.0中，增加了两个丢失的hook以使得处理过程更加清晰。不过这样做并没有给用户带来麻烦，用户只需记住这样一个事实：借助从URL到文件名的hook比最初API设计的目标功能更强大。</p><p>2、令人难以置信的是，mod_rewrite还提供了目录级的URL操作(.htaccess文件)，而这些文件必须在将URL转换成文件名之后才会被处理(这是必须的，因为.htaccess存在于文件系统中)。换句话说，根据API阶段，这时再处理任何URL操作已经太晚了。为了解决这个”鸡和蛋”的问题，mod_rewrite使用了一个小技巧：在进行一个目录级的URL/文件名操作时，先把文件名重写回相应的URL(通常这个操作是不可行的，但是参考下面的RewriteBase指令就能明白它是怎么实现的了)，然后，对这个新的URL建立一个新的内部的子请求，再重新开始API阶段的执行。</p><p>另外，mod_rewrite尽力使这些复杂的操作对用户透明。但仍须记住：服务器级的URL操作速度快而且效率高，而目录级的操作由于这个”鸡和蛋”的问题速度较慢而且效率也低。但从另一个侧面看，这却是mod_rewrite得以为一般用户提供(局部限制的)URL操作的唯一方法。</p><p>Rewirte模块规则集的处理</p><p>当mod_rewrite在这两个API阶段中开始执行时，它会读取配置结构中配置好的 (或者是在服务启动时建立的服务器级的，或者是在遍历目录采集到的目录级的)规则集，然后，启动URL重写引擎来处理(带有一个或多个条件的)规则集。无论是服务器级的还是目录级的规则集，都是由同一个URL重写引擎处理，只是最终结果处理不同而已。</p><p>规则集中规则的顺序是很重要的，因为重写引擎是按一种特殊的顺序处理的：逐个遍历每个规则(RewriteRule指令)，如果出现一个匹配条件的规则，则可能回头遍历已有的规则条件(RewriteCond指令)。由于历史的原因，条件规则是前置的，所以控制流程略显冗长，细节见图-1。</p><p>重写规则集中的控制流</p><p><img src="http://www.yezhongqi.com/wp-content/plugins/wp-ueditor/ueditor/php/upload/93371392111902.gif" alt="image"><br>图-1：重写规则集中的控制流</p><p>可见，URL首先与每个规则的Pattern匹配，如果匹配失败，mod_rewrite将立即终止此规则的处理，继而处理下一个规则。如果匹配成功，mod_rewrite将寻找相应的规则条件，如果一个条件都没有，则简单地用Substitution构造的新值来替换URL，然后继续处理其他规则；但是如果条件存在，则开始一个内部循环按其列出的顺序逐个处理。对规则条件的处理有所不同：URL并不与模式进行匹配，而是首先通过扩展变量、反向引用、查找映射表等步骤建立一个TestString字符串，然后用它来与CondPattern匹配。如果匹配失败，则整个条件集和对应的规则失败；如果匹配成功，则执行下一个规则直到所有条件执行完毕。如果所有条件得以匹配，则以Substitution替换URL，并且继续处理。(本部分引用译者：金步国)</p><p>RewriteCond指令格式</p><p>语法: RewriteCond TestString CondPattern [flags]</p><p>RewriteCond指令定义一条规则条件。在一条RewriteRule指令前面可能会有一条或多条RewriteCond指令，只有当自身的模板(pattern)匹配成功且这些条件也满足时规则才被应用于当前URL处理。</p><p>1、 TestString是一个纯文本的字符串，除了包含普通的字符外，还可以包括下列的可扩展结构：</p><p>1）$N：RewriteRule后向引用，其中(0 &lt;= N &lt;= 9) 。$N引用紧跟在RewriteCond后面的RewriteRule中模板中的括号中的模板在当前URL中匹配的数据。</p><p>2）%N：RewriteCond后向引用，其中(0 &lt;= N &lt;= 9) 。%N引用最后一个RewriteCond的模板中的括号中的模板在当前URL中匹配的数据。</p><p>3）${mapname:key|default}：RewriteMap扩展。</p><p>2、CondPattern是条件pattern, 即一个应用于当前实例TestString的正则表达式, 即TestString将会被计算然后与CondPattern匹配。作为一个标准的扩展正则式，CondPattern有以下补充：</p><p>1）可以在模板串前增加一个!前缀，以用表示不匹配模板。但并不是所有的test都可以加！前缀。</p><p>2)CondPattern中可以使用以下特殊变量：</p><p>‘&gt;CondPattern’ (大于) 将condPattern当作一个普通字符串，将它和TestString进行比较，当TestString 的字符大于CondPattern为真。</p><p>‘=CondPattern’ (等于) 将condPattern当作一个普通字符串，将它和TestString进行比较，当TestString 与CondPattern完全相同时为真.如果CondPattern只是 “” (两个引号紧挨在一起) 此时需TestString 为空字符串方为真。</p><p>‘-d’ (是否为目录) 将testString当作一个目录名，检查它是否存在以及是否是一个目录。</p><p>‘-f’ (是否是regular file) 将testString当作一个文件名，检查它是否存在以及是否是一个regular文件。</p><p>‘-s’ (是否为长度不为0的regular文件) 将testString当作一个文件名，检查它是否存在以及是否是一个长度大于0的regular文件。</p><p>‘-l’ (是否为symbolic link) 将testString当作一个文件名，检查它是否存在以及是否是一个 symbolic link。</p><p>‘-F’ (通过subrequest来检查某文件是否可访问) 检查TestString是否是一个合法的文件，而且通过服务器范围内的当前设置的访问控制进行访问。这个检查是通过一个内部subrequest完成的, 因此需要小心使用这个功能以降低服务器的性能。</p><p>‘-U’ (通过subrequest来检查某个URL是否存在) 检查TestString是否是一个合法的URL，而且通过服务器范围内的当前设置的访问控制进行访问。这个检查是通过一个内部subrequest完成的, 因此需要小心使用这个功能以降低服务器的性能。</p><p>3、[flags]是第三个参数，多个标志之间用逗号分隔。</p><p>1）’nocase|NC’ (不区分大小写) 　　在扩展后的TestString和CondPattern中，比较时不区分文本的大小写。注意，这个标志对文件系统和subrequest检查没有影响.</p><p>2）’ornext|OR’ (建立与下一个条件的或的关系) 　　默认的情况下，二个条件之间是AND的关系，用这个标志将关系改为OR。例如： RewriteCond %{REMOTE_HOST} ^host1.<em> [OR] RewriteCond %{REMOTE_HOST} ^host2.</em> [OR] RewriteCond %{REMOTE_HOST} ^host3.* RewriteRule … 如果没有[OR]标志，需要写三个条件/规则.</p><p>RewriteRule 指令</p><p>语法: RewriteRule Pattern Substitution [flags]</p><p>1) Pattern是一个作用于当前URL的兼容perl的正则表达式. 这里的“当前”是指该规则生效时的URL的值。</p><p>2) Substitution是，当原始URL与Pattern相匹配时，用以替代(或替换)的字符串。</p><p>3) 此外，Substitution还可以追加特殊标记[flags] 作为RewriteRule指令的第三个参数。 Flags是一个包含以逗号分隔的下列标记的列表:</p><p>redirect|R [=code] (强制重定向 redirect)</p><p>以 <a href="http://thishost[:thisport]/(使新的URL成为一个URI" target="_blank" rel="external">http://thishost[:thisport]/(使新的URL成为一个URI</a>) 为前缀的Substitution可以强制性执行一个外部重定向。 如果code没有指定，则产生一个HTTP响应代码302(临时性移动)。如果需要使用在300-400范围内的其他响应代码，只需在此指定这个数值即可， 另外，还可以使用下列符号名称之一: temp (默认的), permanent, seeother. 用它可以把规范化的URL反馈给客户端，如, 重写“/~”为 “/u/”，或对/u/user加上斜杠，等等。</p><p>注意: 在使用这个标记时，必须确保该替换字段是一个有效的URL! 否则，它会指向一个无效的位置! 并且要记住，此标记本身只是对URL加上 <a href="http://thishost[:thisport]/的前缀，重写操作仍然会继续。通常，你会希望停止重写操作而立即重定向，则还需要使用’L’标记" target="_blank" rel="external">http://thishost[:thisport]/的前缀，重写操作仍然会继续。通常，你会希望停止重写操作而立即重定向，则还需要使用’L’标记</a>.</p><p>forbidden|F (强制URL为被禁止的 forbidden)</p><p>强制当前URL为被禁止的，即，立即反馈一个HTTP响应代码403(被禁止的)。使用这个标记，可以链接若干RewriteConds以有条件地阻塞某些URL。</p><p>gone|G’(强制URL为已废弃的 gone)</p><p>强制当前URL为已废弃的，即，立即反馈一个HTTP响应代码410(已废弃的)。使用这个标记，可以标明页面已经被废弃而不存在了.</p><p>proxy|P (强制为代理 proxy)</p><p>此标记使替换成分被内部地强制为代理请求，并立即(即， 重写规则处理立即中断)把处理移交给代理模块。你必须确保此替换串是一个有效的(比如常见的以 <a href="http://hostname开头的)能够为Apache代理模块所处理的URI。使用这个标记，可以把某些远程成分映射到本地服务器名称空间，" target="_blank" rel="external">http://hostname开头的)能够为Apache代理模块所处理的URI。使用这个标记，可以把某些远程成分映射到本地服务器名称空间，</a> 从而增强了ProxyPass指令的功能。</p><p>注意: 要使用这个功能，代理模块必须编译在Apache服务器中。 如果你不能确定，可以检查“httpd -l”的输出中是否有mod_proxy.c。 如果有，则mod_rewrite可以使用这个功能；如果没有，则必须启用mod_proxy并重新编译“httpd”程序。</p><p>last|L (最后一个规则 last)</p><p>立即停止重写操作，并不再应用其他重写规则。 它对应于Perl中的last命令或C语言中的break命令。这个标记可以阻止当前已被重写的URL为其后继的规则所重写。 举例，使用它可以重写根路径的URL(’/’)为实际存在的URL, 比如, ‘/e/www/’.</p><p>next|N (重新执行 next round)</p><p>重新执行重写操作(从第一个规则重新开始). 这时再次进行处理的URL已经不是原始的URL了，而是经最后一个重写规则处理的URL。它对应于Perl中的next命令或C语言中的continue命令。 此标记可以重新开始重写操作，即, 立即回到循环的头部。<br>但是要小心，不要制造死循环!</p><p>chain|C (与下一个规则相链接 chained)</p><p>此标记使当前规则与下一个(其本身又可以与其后继规则相链接的， 并可以如此反复的)规则相链接。 它产生这样一个效果: 如果一个规则被匹配，通常会继续处理其后继规则， 即，这个标记不起作用；如果规则不能被匹配，则其后继的链接的规则会被忽略。比如，在执行一个外部重定向时， 对一个目录级规则集，你可能需要删除“.www” (此处不应该出现“.www”的)。</p><p>type|T=MIME-type(强制MIME类型 type)</p><p>强制目标文件的MIME类型为MIME-type。 比如，它可以用于模拟mod_alias中的ScriptAlias指令，以内部地强制被映射目录中的所有文件的MIME类型为“application/x-httpd-cgi”。</p><p>nosubreq|NS (仅用于不对内部子请求进行处理 no internal sub-request)</p><p>在当前请求是一个内部子请求时，此标记强制重写引擎跳过该重写规则。比如，在mod_include试图搜索可能的目录默认文件(index.xxx)时， Apache会内部地产生子请求。对子请求，它不一定有用的，而且如果整个规则集都起作用，它甚至可能会引发错误。所以，可以用这个标记来排除某些规则。</p><p>根据你的需要遵循以下原则: 如果你使用了有CGI脚本的URL前缀，以强制它们由CGI脚本处理，而对子请求处理的出错率(或者开销)很高，在这种情况下，可以使用这个标记。</p><p>nocase|NC (忽略大小写 no case)</p><p>它使Pattern忽略大小写，即, 在Pattern与当前URL匹配时，’A-Z’ 和’a-z’没有区别。</p><p>qsappend|QSA (追加请求串 query string append)</p><p>此标记强制重写引擎在已有的替换串中追加一个请求串，而不是简单的替换。如果需要通过重写规则在请求串中增加信息，就可以使用这个标记。</p><p>noescape|NE (在输出中不对URI作转义 no URI escaping)</p><p>此标记阻止mod_rewrite对重写结果应用常规的URI转义规则。 一般情况下，特殊字符(如’%’, ‘$’, ‘;’等)会被转义为等值的十六进制编码。 此标记可以阻止这样的转义，以允许百分号等符号出现在输出中，如：</p><p>RewriteRule /foo/(.*) /bar?arg=P1\=$1 [R,NE] 可以使’/foo/zed’转向到一个安全的请求’/bar?arg=P1=zed’.</p><p>passthrough|PT (移交给下一个处理器 pass through)</p><p>此标记强制重写引擎将内部结构request_rec中的uri字段设置为 filename字段的值，它只是一个小修改，使之能对来自其他URI到文件名翻译器的 Alias，ScriptAlias, Redirect 等指令的输出进行后续处理。举一个能说明其含义的例子：如果要通过mod_rewrite的重写引擎重写/abc为/def，然后通过mod_alias使/def转变为/ghi，可以这样:</p><p>RewriteRule ^/abc(.*) /def$1 [PT]<br>Alias /def /ghi<br>如果省略了PT标记，虽然mod_rewrite运作正常， 即, 作为一个使用API的URI到文件名翻译器，它可以重写uri=/abc/…为filename=/def/…，但是，后续的mod_alias在试图作URI到文件名的翻译时，则会失效。</p><p>注意: 如果需要混合使用不同的包含URI到文件名翻译器的模块时， 就必须使用这个标记。。混合使用mod_alias和mod_rewrite就是个典型的例子。</p><p>For Apache hackers</p><p>如果当前Apache API除了URI到文件名hook之外，还有一个文件名到文件名的hook， 就不需要这个标记了! 但是，如果没有这样一个hook，则此标记是唯一的解决方案。 Apache Group讨论过这个问题，并在Apache 2.0 版本中会增加这样一个hook。</p><p>skip|S=num (跳过后继的规则 skip)</p><p>此标记强制重写引擎跳过当前匹配规则后继的num个规则。 它可以实现一个伪if-then-else的构造: 最后一个规则是then从句，而被跳过的skip=N个规则是else从句. (它和’chain|C’标记是不同的!)</p><p>env|E=VAR:VAL (设置环境变量 environment variable)</p><p>此标记使环境变量VAR的值为VAL, VAL可以包含可扩展的反向引用的正则表达式$N和%N。 此标记可以多次使用以设置多个变量。这些变量可以在其后许多情况下被间接引用，但通常是在XSSI (via ) or CGI (如 $ENV{’VAR’})中， 也可以在后继的RewriteCond指令的pattern中通过%{ENV:VAR}作引用。使用它可以从URL中剥离并记住一些信息。</p><p>cookie|CO=NAME:VAL:domain[:lifetime[:path]] (设置cookie)</p><p>它在客户端浏览器上设置一个cookie。 cookie的名称是NAME，其值是VAL。 domain字段是该cookie的域，比如’.apache.org’, 可选的lifetime是cookie生命期的分钟数，可选的path是cookie的路径。</p><p>案例：</p><p>city_map.txt的内容：</p><p>hangzhou 12</p><p>beijing 13</p><p>1、hangzhou.google.com/tianqi/20090401 跳转到 www.google.com/service/detail.html?id=tianqi&amp;date=20090401</p><p>RewriteMap city–map txt:/etc/httpd/conf.d/map/city_map.txt</p><p>RewriteCond %{HTTP_HOST}    ^(.+).google.com$</p><p>RewriteRule ^/([\w]+)/([\d]+)$ /service/detail.html\?id=$1&amp;date=$2&amp;c=${city–map:%1|%1} [PT,L]</p><p>解释：</p><p>%{HTTP_HOST}：取请求的域名</p><p>^(.+).google.com$：^,开头；$结尾。.（逗号），除终止符外的任意字符。+，重复一个或一个以上的字符。\，转义字符。</p><p>^/([\w]+)/([\d]+)$：[]，集合字符。\w，数字或字母。\d，数字。</p><p>$1：表示的是符合RewriteRule 中[\w]+正则式的字符串，也就是tianqi。</p><p>$2：表示的是符合RewriteRule 中[\d]+ 正则式的字符串，也就是20090401。</p><p>%1：表示的是符合RewriteCond 中.+正则式的字符串，也就是hangzhou。</p><p>${city-map:%1|%1}：表示取city-map中%1也就是hangzhou对应的值，如果没有则为%1也就是hangzhou。</p><p>2、能看出下面的规则是做了什么吗？</p><p>RewriteCond     %{HTTP_HOST}    ^(.+).google.com$</p><p>RewriteRule ^/([\w]+)/([^-]+)–([^-]+)—([^-]+)–([^-]+)—([^-]+)–([^-]+)—([^-]+-[^-]+–[^-]+-[^-]+–[^-]+-[^-]+)$  /$1/$2=$3&amp;$4=$5&amp;$6=$7&amp;$8   [C]</p><p>RewriteCond     %{HTTP_HOST}    ^(.+).google.com$</p><p>RewriteRule ^/([\w]+)/([^-]+)–([^-]+)—([^-]+)–([^-]+)—([^-]+)–([^-]+)$     /service/list.html\?frontCategoryId=${category–map:$1|0}&amp;$2=$3&amp;$4=$5&amp;$6=$7&amp;city=${city–map:%1|%1}   [PT,L]</p><p>解释：</p><p>这个规则是想把-（中划线）转为=，把- -（两条中划线）转为&amp;。</p><p>[^-]：^在字符集合符号（[]）之内表示反向选择，之外表示行首，所以表示不以-开头。</p><p>因为$N，N最大为9，所以使用了C，用第二条RewriteRule把第一条RewriteRule中的最后一个节点，即$8，进行继续转换。</p><p>此外，rewrite规则中如果遇到中文，相当有可能会出现乱码问题，因为apache在rewrite时会做一次url解码，这时jk进行请求转发时，就不会再是编码后的字符串了。此种情况，可以在一开始就进行两次编码(encode)，或者在接收请求时先用ISO-8859-1取字节流，再使用UFT-8来new String。(new String(str.getBytes(”ISO-8859-1″),”UFT-8″))</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;是什么&quot;&gt;&lt;a href=&quot;#是什么&quot; class=&quot;headerlink&quot; title=&quot;是什么&quot;&gt;&lt;/a&gt;是什么&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;维基百科&lt;/strong&gt;路由（routing）就是通过互联的网络把信息从源地址传输到目的地址的活动。路由发生在OSI网络参考模型中的第三层即网路层。路由引导分组转送，经过一些中间的节点后，到它们最后的目的地。作成硬件的话，则称为路由器。&lt;br&gt;在php中的路由同OSI中路由的作用相似, 用来处理接收到的请求，将请求指向相应的控制器或者处理程序.&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>微信开发-1</title>
    <link href="http://yoursite.com/2016/06/16/%E5%BE%AE%E4%BF%A1%E5%BC%80%E5%8F%91-1/"/>
    <id>http://yoursite.com/2016/06/16/微信开发-1/</id>
    <published>2016-06-16T02:01:49.000Z</published>
    <updated>2017-06-07T07:15:51.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="微信开发"><a href="#微信开发" class="headerlink" title="微信开发"></a>微信开发</h1><p>准备写2-3篇, 没什么意义, 建议直接看官方文档.</p><a id="more"></a><h2 id="申请订阅号"><a href="#申请订阅号" class="headerlink" title="申请订阅号"></a>申请订阅号</h2><ol><li><p>服务号,订阅号,企业号的区别(<a href="https://kf.qq.com/faq/120911VrYVrA130805byM32u.html" target="_blank" rel="external">官方说明</a>)</p><ul><li>订阅号：主要偏于为用户传达资讯（类似报纸杂志），认证前后都是每天只可以群发一条消息；</li><li>服务号：主要偏于服务交互（类似银行，114，提供服务查询），认证前后都是每个月可群发4条消息；</li><li><p>企业号：主要用于公司内部通讯使用，需要先有成员的通讯信息验证才可以关注成功企业号；</p><p>个人用户只能申请订阅号, 以下以订阅号为例.</p><p><a href="https://mp.weixin.qq.com/cgi-bin/readtemplate?t=register/step1_tmpl&amp;lang=zh_CN" target="_blank" rel="external">注册</a>成功之后可以通过网站管理你的个人订阅号, 为方便接口测试, 微信为我们提供了公众平台测试账号, 接下来我们通过测试号来了解常用接口的使用.<br><img src="http://7xr09w.com1.z0.glb.clouddn.com/QQ20160615-1.png" alt="测试号"></p></li></ul></li><li><p>接口权限配置</p><p> <img src="http://7xr09w.com1.z0.glb.clouddn.com/QQ20160615-2.png" alt=""></p><p> 这里需要验证服务器, 如果是个人服务器需要有80端口权限, 这里使用新浪sae来演示.<br> 微信为我们提供了验证的<a href="http://mp.weixin.qq.com/mpres/htmledition/res/wx_sample.20140819.zip" target="_blank" rel="external">示例代码</a>, 修改代码中的token为自定义的token</p><p> <img src="http://7xr09w.com1.z0.glb.clouddn.com/QQ20160615-0@2x.png" alt=""></p><p> 将这个php文件上传至sae, 在配置的URL处填写路径, Token中填写代码中的token, 提交.</p></li></ol><h2 id="接口调用"><a href="#接口调用" class="headerlink" title="接口调用"></a>接口调用</h2><p>接下来就可以测试微信提供的各种接口了, 包括用户消息管理, 收发, 用户信息等等, 可以在<a href="http://mp.weixin.qq.com/wiki/home/index.html" target="_blank" rel="external">微信开发者文档</a>中查看所有接口的指南, 这里演示两个例子.</p><h3 id="获取用户列表"><a href="#获取用户列表" class="headerlink" title="获取用户列表"></a>获取用户列表</h3><ol><li><p>获取<em>access_token</em></p><p> 为保证安全, 接口的调用一般分两步或者三步完成.首先第一步需要获取<em>access_token</em>, 接下来所有的接口都需要通过该<em>access_token</em>来进行调用, 通过下面的接口可以获取access_token, 参数为appid和appsecret:</p><pre><code>https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&amp;appid=APPID&amp;secret=APPSECRET</code></pre><p> 请求成功的返回值为:</p><pre><code>{&quot;access_token&quot;:&quot;ACCESS_TOKEN&quot;,&quot;expires_in&quot;:7200}</code></pre><p> 需要注意的是这个接口每天的调用次数为2000次, 每次请求到的access_token有效期为两小时, 每次调用产生的token值都不一样, 因此建议将此token保存至数据库中, 过期替换即可, 防止请求次数超限. </p><p> 如何使用php调用接口<a href="#使用php调用接口">点这里</a></p></li><li><p>通过token获取用户列表</p><p> 在公众号中, 用户通过OpenID来标识, 每一个用户相对于同一个公众号的OpenID是固定的, 因此获取用户列表返回的内容为所有OpenID的数组, 一次请求最多拉取10000个用户, 可以通过设置参数中的next_openid多次拉取.<br> 接口中两个参数:</p><p> access_token(第一步获取到的token)<br> next_openid(不填默认为从头开始)</p><pre><code>https://api.weixin.qq.com/cgi-bin/user/get?access_token=ACCESS_TOKEN&amp;next_openid=NEXT_OPENID</code></pre><p> 返回值:</p><pre><code>{&quot;total&quot;:2,&quot;count&quot;:2,&quot;data&quot;:{&quot;openid&quot;:[&quot;&quot;,&quot;OPENID1&quot;,&quot;OPENID2&quot;]},&quot;next_openid&quot;:&quot;NEXT_OPENID&quot;}</code></pre></li><li><p>获取用户基本信息</p><p> 获取到OpenID之后可以通过OpenID获取到对应用户的基本信息, 包括昵称、头像、性别、所在城市、语言和关注时间。</p><pre><code>https://api.weixin.qq.com/cgi-bin/user/info?access_token=ACCESS_TOKEN&amp;openid=OPENID&amp;lang=zh_CN</code></pre><p> 返回值</p><pre><code>{    &quot;subscribe&quot;: 1,     &quot;openid&quot;: &quot;o6_bmjrPTlm6_2sgVt7hMZOPfL2M&quot;,     &quot;nickname&quot;: &quot;Band&quot;,     &quot;sex&quot;: 1,     &quot;language&quot;: &quot;zh_CN&quot;,     &quot;city&quot;: &quot;广州&quot;,     &quot;province&quot;: &quot;广东&quot;,     &quot;country&quot;: &quot;中国&quot;,     &quot;headimgurl&quot;: &quot;http://wx.qlogo.cn/mmopen/g3MonUZtNHkdmzicIlibx6iaFqAc56vxLSUfpb6n5WKSYVY0ChQKkiaJSgQ1dZuTOgvLLrhJbERQQ4eMsv84eavHiaiceqxibJxCfHe/0&quot;,     &quot;subscribe_time&quot;: 1382694957,    &quot;unionid&quot;: &quot; o6_bmasdasdsad6_2sgVt7hMZOPfL&quot;    &quot;remark&quot;: &quot;&quot;,    &quot;groupid&quot;: 0}</code></pre></li></ol><h3 id="第三方网页授权获取用户基本信息"><a href="#第三方网页授权获取用户基本信息" class="headerlink" title="第三方网页授权获取用户基本信息"></a>第三方网页授权获取用户基本信息</h3><p>如果用户在微信中直接访问网页, 公众号可以通过微信的授权机制, 来获取用户的基本信息.<br>基本流程为:</p><ol><li><a href="#设置授权回调域名">设置授权回调域名</a></li><li><a href="#引导用户打开网页">用户进入第三方网页</a>, 会显示以下内容<br> <img src="http://mp.weixin.qq.com/wiki/static/assets/421812a0f2587f921c51413a84ac527b.png" alt=""></li><li><a href="#授权成功回调">授权通过后会自动返回到开发者设置的回调页面, 并传入一个code参数</a></li><li><a href="">通过code参数获取网页授权的access_token(不同于上边的access_token)</a></li><li><a href="#拉取用户信息">通过access_token和OpenID获取用户基本信息</a></li></ol><p>注: 订阅号没有此接口的权限, 通过测试号模拟  </p><h4 id="设置授权回调域名"><a href="#设置授权回调域名" class="headerlink" title="设置授权回调域名"></a>设置授权回调域名</h4><p>在测试号管理页面中配置授权回调域名, sae的域名为xxx.applinzi.com</p><p><img src="http://7xr09w.com1.z0.glb.clouddn.com/QQ20160615-3.png" alt=""></p><h4 id="引导用户打开网页"><a href="#引导用户打开网页" class="headerlink" title="引导用户打开网页"></a>引导用户打开网页</h4><p>引导用户打开接口, 参数:</p><pre><code>// appid: appid// redirect_url: 授权成功后的回调页// scope: 应用授权作用域，snsapi_base （不弹出授权页面，直接跳转，只能获取用户openid），snsapi_userinfo （弹出授权页面，可通过openid拿到昵称、性别、所在地。并且，即使在**未关注**的情况下，只要用户授权，也能获取其信息）https://open.weixin.qq.com/connect/oauth2/authorize?appid=APPID&amp;redirect_uri=REDIRECT_URI&amp;response_type=code&amp;scope=SCOPE&amp;state=STATE#wechat_redirect</code></pre><h4 id="授权成功回调"><a href="#授权成功回调" class="headerlink" title="授权成功回调"></a>授权成功回调</h4><p>当用户同意授权后, 会向回调页传入一个code参数, 通过此code我们可以获取到接下来要用的access_token(注意这个token和之前的token不是同一个)</p><p>接口</p><pre><code>https://api.weixin.qq.com/sns/oauth2/access_token?appid=APPID&amp;secret=SECRET&amp;code=CODE&amp;grant_type=authorization_code</code></pre><p>返回值</p><pre><code>{    &quot;access_token&quot;:&quot;ACCESS_TOKEN&quot;,    &quot;expires_in&quot;:7200,    &quot;refresh_token&quot;:&quot;REFRESH_TOKEN&quot;,    &quot;openid&quot;:&quot;OPENID&quot;,    &quot;scope&quot;:&quot;SCOPE&quot;,    &quot;unionid&quot;: &quot;o6_bmasdasdsad6_2sgVt7hMZOPfL&quot;}</code></pre><h4 id="拉取用户信息"><a href="#拉取用户信息" class="headerlink" title="拉取用户信息"></a>拉取用户信息</h4><p>通过上一步获取到access_token和OpenID之后就可以获取该用户的基本信息了</p><p>接口</p><pre><code>https://api.weixin.qq.com/sns/userinfo?access_token=ACCESS_TOKEN&amp;openid=OPENID&amp;lang=zh_CN</code></pre><p>返回值</p><pre><code>{   &quot;openid&quot;:&quot; OPENID&quot;,   &quot; nickname&quot;: NICKNAME,   &quot;sex&quot;:&quot;1&quot;,   &quot;province&quot;:&quot;PROVINCE&quot;   &quot;city&quot;:&quot;CITY&quot;,   &quot;country&quot;:&quot;COUNTRY&quot;,    &quot;headimgurl&quot;:    &quot;http://wx.qlogo.cn/mmopen/g3MonUZtNHkdmzicIlibx6iaFqAc56vxLSUfpb6n5WKSYVY0ChQKkiaJSgQ1dZuTOgvLLrhJbERQQ4eMsv84eavHiaiceqxibJxCfHe/46&quot;,     &quot;privilege&quot;:[    &quot;PRIVILEGE1&quot;    &quot;PRIVILEGE2&quot;    ],    &quot;unionid&quot;: &quot;o6_bmasdasdsad6_2sgVt7hMZOPfL&quot;}</code></pre><hr><h2 id="使用php调用接口"><a href="#使用php调用接口" class="headerlink" title="使用php调用接口"></a>使用php调用接口</h2><p>在php中, 可以直接通过file_get_content来获取数据, 但是因为file_get_content的使用不够灵活, 而且简单的get请求可以通过file_get_content实现, POST请求的内容无法获取, 因此我们使用php的cURL扩展来调用微信的各类接口, 建议将常用的函数进行封装方便重复调用.</p><blockquote><p>PHP支持的由Daniel Stenberg创建的libcurl库允许你与各种的服务器使用各种类型的协议进行连接和通讯。</p></blockquote><p>GET请求的方法, 参数为请求的url</p><pre><code>function httpGet($url) {    $curl = curl_init();    curl_setopt($curl, CURLOPT_RETURNTRANSFER, true);    curl_setopt($curl, CURLOPT_TIMEOUT, 500);    // 为保证第三方服务器与微信服务器之间数据传输的安全性，所有微信接口采用https方式调用，必须使用下面2行代码打开ssl安全校验。    // 如果在部署过程中代码在此处验证失败，请到 http://curl.haxx.se/ca/cacert.pem 下载新的证书判别文件。    curl_setopt($curl, CURLOPT_SSL_VERIFYPEER, true);    //验证token, 本地可以注释掉, 上线必须打开    // curl_setopt($curl, CURLOPT_SSL_VERIFYHOST, true);    curl_setopt($curl, CURLOPT_URL, $url);    $res = curl_exec($curl);    curl_close($curl);    return $res;}</code></pre><p>POST请求的方法, 参数为请求体body和请求的url</p><pre><code>function httpPost ($data,$url){    $ch = curl_init();    curl_setopt($ch, CURLOPT_URL, $url);    curl_setopt($ch, CURLOPT_CUSTOMREQUEST, &quot;POST&quot;);    curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, FALSE);    curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, FALSE);    curl_setopt($ch, CURLOPT_USERAGENT, &apos;Mozilla/5.0 (compatible; MSIE 5.01; Windows NT 5.0)&apos;);    curl_setopt($ch, CURLOPT_FOLLOWLOCATION, 1);    curl_setopt($ch, CURLOPT_AUTOREFERER, 1);    curl_setopt($ch, CURLOPT_POSTFIELDS, $data);    curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);    $tmpInfo = curl_exec($ch);    if (curl_errno($ch)) {        return curl_error($ch);    }    curl_close($ch);    return $tmpInfo;}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;微信开发&quot;&gt;&lt;a href=&quot;#微信开发&quot; class=&quot;headerlink&quot; title=&quot;微信开发&quot;&gt;&lt;/a&gt;微信开发&lt;/h1&gt;&lt;p&gt;准备写2-3篇, 没什么意义, 建议直接看官方文档.&lt;/p&gt;
    
    </summary>
    
    
      <category term="html5" scheme="http://yoursite.com/tags/html5/"/>
    
  </entry>
  
  <entry>
    <title>JS中事件的版本兼容</title>
    <link href="http://yoursite.com/2016/05/17/%E4%BA%8B%E4%BB%B6%E7%89%88%E6%9C%AC%E5%85%BC%E5%AE%B9/"/>
    <id>http://yoursite.com/2016/05/17/事件版本兼容/</id>
    <published>2016-05-16T16:54:49.000Z</published>
    <updated>2016-06-16T02:41:01.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="版本兼容的一些问题"><a href="#版本兼容的一些问题" class="headerlink" title="版本兼容的一些问题"></a>版本兼容的一些问题</h1><h4 id="addEventListener和attachEvent"><a href="#addEventListener和attachEvent" class="headerlink" title="addEventListener和attachEvent"></a>addEventListener和attachEvent</h4><p>给元素简单的添加事件,通过</p><pre><code>obj.onclick = function () {};</code></pre><p>这个方法是可以兼容主流浏览器的,但是如果同时添加多个事件的时候之前的事件会被后添加的事件覆盖.在<strong>现代浏览器中</strong>,我们可以通过<code>addEventListener()</code>这个方法来给元素添加事件监听,实现事件绑定的效果</p><a id="more"></a><pre><code>/** * event: 要绑定的事件的字符串 * function: 事件触发时对应的函数 * useCapturn: (可选)是否事件捕获, bool值 */obj.addEventListener(event, function, useCapture)</code></pre><p>关于事件捕获, 看<a href="#事件捕获与事件冒泡">这里</a>.</p><p>而对于陈旧的<strong>IE</strong>来说,有一个专属的<code>attachEvent()</code>方法来实现同样的效果</p><pre><code>/** * event: 要绑定的事件的字符串, 注意要加on, 如&quot;onclick&quot; * function: 事件触发时对应的函数 */obj.attachEvent(event, function)</code></pre><p>这个方法是IE浏览器独有的, 所以我们在封装的时候根据两种情况分别处理:</p><pre><code>/**  * 添加事件  * @param {eventName: 事件名}      * @param {obj: 要添加事件的对象}  * @param {事件的回调} */function addEvent(eventName, obj, fn) {    if (obj.addEventListener) {        obj.addEventListener(eventName, fn, false);    }else {        obj.attachEvent(&quot;on&quot;+eventName, fn);    }}</code></pre><h4 id="事件捕获与事件冒泡"><a href="#事件捕获与事件冒泡" class="headerlink" title="事件捕获与事件冒泡"></a>事件捕获与事件冒泡</h4><p><span id="jump"></span><br>假如有如下的页面结构, 即绿色元素嵌套了红色元素, 如果给两个元素都绑定点击事件, 那么当用户点击红色元素时, 两个元素的事件应该以什么顺序执行, 而且点击红色时如何阻止绿色的事件.</p><p><img src="http://7xr09w.com1.z0.glb.clouddn.com/capture.png" alt="div嵌套"></p><p>最早网景和微软采取的是两套策略:</p><ul><li>网景主张绿色元素的事件先触发, 称为捕获型(capturing). 即点击红色元素时, 父级视图(绿色)会先响应事件, 红色元素的事件最后被触发.</li><li>微软主张红色元素的事件先触发, 称为冒泡型(bubbling). 即点击红色元素时, 红色元素的事件会先被触发, 最后触发父级视图的事件.<br>W3C采取了折衷的办法, 任何发生在w3c事件模型中的事件，首是进入捕获阶段，到达目标元素，再进入冒泡阶段.</li></ul><p>我们可以通过addEventListener方法来确定是在捕获时触发事件, 还是在冒泡时绑定函数, 如果最后一个参数为true, 则在捕获阶段绑定事件, 如果为false, 在冒泡阶段绑定事件, 比如:</p><pre><code>smallDiv.addEventListener(&quot;click&quot;, function  () {    alert(&quot;小&quot;);}, false);bigDiv.addEventListener(&quot;click&quot;, function () {    alert(&quot;大&quot;);}, true); </code></pre><p>显示的顺序为大-&gt;小, 分析一下事件的响应过程</p><ol><li>当点击红色元素(smallDiv)时, 事件进入捕获阶段, 首先找到父级视图(bigDiv), 父级视图设置为true, 函数在捕获阶段绑定, 所以先执行alert(“大”), 然后向上找, 找到自己, 为false, 所以没有函数执行.</li><li>进入冒泡阶段, 首先从自身开始, 执行alert(“小”), 然后向下找, 父级视图上没有在冒泡阶段绑定的事件, 所以没有函数继续执行</li></ol><p>如果:</p><pre><code>smallDiv.addEventListener(&quot;click&quot;, function  () {    alert(&quot;小&quot;);}, true);    bigDiv.addEventListener(&quot;click&quot;, function () {    alert(&quot;大&quot;);}, false);</code></pre><p>显示顺序为相反, 小-&gt;大, 分析:</p><ol><li>点击红色时, 进入事件捕获阶段, 先从父视图上开始查找, 发现父级视图事件捕获设置为false, 是在冒泡阶段绑定的, 所以不执行, 开始向上找, 找到红色视图自己, true, 弹出”小”, 绑定阶段结束</li><li>冒泡阶段开始, 首先自身的事件没有在冒泡阶段绑定, 所以向下找, 发现父级视图的事件是在这个阶段绑定的, 所以弹出”大”.</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;版本兼容的一些问题&quot;&gt;&lt;a href=&quot;#版本兼容的一些问题&quot; class=&quot;headerlink&quot; title=&quot;版本兼容的一些问题&quot;&gt;&lt;/a&gt;版本兼容的一些问题&lt;/h1&gt;&lt;h4 id=&quot;addEventListener和attachEvent&quot;&gt;&lt;a href=&quot;#addEventListener和attachEvent&quot; class=&quot;headerlink&quot; title=&quot;addEventListener和attachEvent&quot;&gt;&lt;/a&gt;addEventListener和attachEvent&lt;/h4&gt;&lt;p&gt;给元素简单的添加事件,通过&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;obj.onclick = function () {};
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这个方法是可以兼容主流浏览器的,但是如果同时添加多个事件的时候之前的事件会被后添加的事件覆盖.在&lt;strong&gt;现代浏览器中&lt;/strong&gt;,我们可以通过&lt;code&gt;addEventListener()&lt;/code&gt;这个方法来给元素添加事件监听,实现事件绑定的效果&lt;/p&gt;
    
    </summary>
    
    
      <category term="html5" scheme="http://yoursite.com/tags/html5/"/>
    
  </entry>
  
  <entry>
    <title>mac下使用WireShark抓包</title>
    <link href="http://yoursite.com/2016/03/17/mac%E4%B8%8B%E4%BD%BF%E7%94%A8WireShark%E6%8A%93%E5%8C%85/"/>
    <id>http://yoursite.com/2016/03/17/mac下使用WireShark抓包/</id>
    <published>2016-03-16T16:54:49.000Z</published>
    <updated>2016-05-18T03:53:35.000Z</updated>
    
    <content type="html"><![CDATA[<p>文章来自:<a href="http://dingtwo.github.io/2016/03/17/mac下使用WireShark抓包/" target="_blank" rel="external">Ding</a><br>常用的手机网络抓包方式在mac下可以用Charles或者paros,手机上可以用Replica,但是这两种方式都有一些缺点,手机抓包的缺点是使用不方便,只适用用在一些简单的环境,Charles等软件的缺点是每次都需要手动修改手机的服务器和端口号,而且只能抓取wifi状态下的网络包,无法在移动网络环境下(公司渣网速 <strong>PK</strong> 4G)使用,因此重新找了一个其他的方法,操作简单,而且支持手机各种网络状态.<br><a id="more"></a></p><p><a href="https://zh.wikipedia.org/wiki/Wireshark" target="_blank" rel="external">WireShark</a>是一个免费开源的网络数据包分析软件。</p><ol><li><p>安装Wireshark<a href="https://www.wireshark.org/download.html" target="_blank" rel="external">官网下载</a><br> 这一步我在安装成功之后一直卡在主页显示配置首选项,<img src="http://7xr09w.com1.z0.glb.clouddn.com/wireshark_waiting.png" alt=""><br>重启电脑之后顺利进入.<br>这一步如果提示需要X11环境的话进行下一步,否则跳过直接到3,因为WireShark旧版本需要X11环境,新版本可以直接使用.</p></li><li><p>安装XQuartz<a href="http://www.xquartz.org/" target="_blank" rel="external">官网下载</a>.</p><p> 安装完成会提示注销,然后重新登录,就可以使XQuartz作为默认的X11Server<br> <img src="http://img.blog.csdn.net/20140815211812328" alt=""></p></li><li><p>使用苹果在 iOS 5 中新引入了“远程虚拟接口（Remote Virtual Interface,RVI）”的特性，可以在 Mac 中建立一个虚拟网络接口来作为 iOS 设备的网络栈，这样所有经过 iOS 设备的流量都会经过此虚拟接口。此虚拟接口只是监听 iOS 设备本身的协议栈（但并没有将网络流量中转到 Mac 本身的网络连接上），所有网络连接都是 iOS 设备本身的，与 Mac 电脑本身联不联网或者联网类型无关。iOS设备本身可以为任意网络类型（WiFi/xG），这样在 Mac 电脑上使用任意抓包工具（tcpdump、Wireshark、CPA）抓取 RVI 接口上的数据包就实现了对 iPhone 的抓包。</p><p> 通过iTunes手机的UDID:<br> <img src="http://7xr09w.com1.z0.glb.clouddn.com/wiresharkitunes_UDID.png" alt="通过iTunes获取UDID"></p><p> 或在Xcode的菜单Window-&gt;Devices中获取:<br> <img src="http://7xr09w.com1.z0.glb.clouddn.com/wiresharkxcode_udid.png" alt="通过Xcode获取UDID"></p></li><li><p>在终端使用rvictl命令创建RVI接口(remote virtual interface),使用iPhone的UDID作为参数。</p><pre><code>$ rvictl -s UDID</code></pre><p> <img src="http://7xr09w.com1.z0.glb.clouddn.com/wiresharkstart.png" alt=""></p></li></ol><ol><li><p>终端输入ifconfig -l可以看到多了一个rvi0的虚拟接口</p></li><li><p>打开WireShark,点击设置按钮,可以看到所有的虚拟接口,选择rvi0,点击开始<br> <img src="http://7xr09w.com1.z0.glb.clouddn.com/wiresharkwireShark_set.png" alt=""></p></li><li><p>接下来就可以看到当前连接手机的所有网络活动,可以在菜单栏下的过滤器里选择HTTP即可抓取所有HTTP协议的请求了<br> <img src="http://7xr09w.com1.z0.glb.clouddn.com/http.png" alt=""></p></li><li><p>在抓包完成之后记得需要移除创建的虚拟端口</p><pre><code>$ rvictl -x UDID</code></pre></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;文章来自:&lt;a href=&quot;http://dingtwo.github.io/2016/03/17/mac下使用WireShark抓包/&quot;&gt;Ding&lt;/a&gt;&lt;br&gt;常用的手机网络抓包方式在mac下可以用Charles或者paros,手机上可以用Replica,但是这两种方式都有一些缺点,手机抓包的缺点是使用不方便,只适用用在一些简单的环境,Charles等软件的缺点是每次都需要手动修改手机的服务器和端口号,而且只能抓取wifi状态下的网络包,无法在移动网络环境下(公司渣网速 &lt;strong&gt;PK&lt;/strong&gt; 4G)使用,因此重新找了一个其他的方法,操作简单,而且支持手机各种网络状态.&lt;br&gt;
    
    </summary>
    
    
      <category term="mac" scheme="http://yoursite.com/tags/mac/"/>
    
  </entry>
  
  <entry>
    <title>CSS3增加的一些选择器</title>
    <link href="http://yoursite.com/2016/02/29/CSS3%E5%A2%9E%E5%8A%A0%E7%9A%84%E4%B8%80%E4%BA%9B%E9%80%89%E6%8B%A9%E5%99%A8/"/>
    <id>http://yoursite.com/2016/02/29/CSS3增加的一些选择器/</id>
    <published>2016-02-29T03:49:16.000Z</published>
    <updated>2016-05-18T03:53:35.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="CSS3的组合选择器"><a href="#CSS3的组合选择器" class="headerlink" title="CSS3的组合选择器"></a>CSS3的组合选择器</h3><p>在CCS3中增加了一些组合选择器,方便更多条件的查找,jQuery等都可以根据组合选择器来选择元素.<br><a id="more"></a></p><ul><li><p>子元素选择器</p>  <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&gt;<span class="selector-tag">p</span>&#123;</span><br><span class="line"><span class="attribute">background-color</span>: yellow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>表示div的下一级元素为p标签时p标签的样式.<br><!-- more --></p><ul><li><p>相邻兄弟选择器(Adjacent sibling selector)</p>  <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">h1</span>+<span class="selector-tag">p</span>&#123;</span><br><span class="line"><span class="attribute">color</span>: yellow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  标签样式如下,对相邻元素的后一个元素有效.<br>  注意两点:</p><ul><li>注意是<strong>相邻</strong>,所以中间如果有其他元素这个样式就无效了.</li><li>相邻元素的后<strong>一个</strong>元素,所以如果之后再有p元素也不满足这个样式的条件</li></ul></li></ul><pre><code><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>这是另一个h1<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>这是另一个p<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure></code></pre><ul><li><p>同级元素通用选择器</p>  <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">h1</span>~<span class="selector-tag">div</span>&#123;</span><br><span class="line"><span class="attribute">color</span>: green;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  匹配任何在h1之后的同级div元素.<br>  和上一个标签作对比:</p><ul><li>没有相邻的条件约束,所以只要是h1之后的<strong>同级</strong>标签是div就有效</li><li>没有后一个条件约束,h1之后所有的同级div标签都有效</li></ul></li><li><p>属性选择器</p>  <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">*<span class="selector-attr">[title]</span>&#123;</span><br><span class="line"><span class="attribute">color</span>: red;</span><br><span class="line"><span class="attribute">border</span>: <span class="number">5px</span> solid red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  匹配所有带有title的元素.可以多个属性查询,比如:</p>  <figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a[<span class="string">href</span>][<span class="symbol">title</span>]&#123;</span><br><span class="line"><span class="code">color: red;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  还可以直接匹配属性的值,比如:</p>  <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">a</span><span class="selector-attr">[href="###"]</span>&#123;</span><br><span class="line"><span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  还可以使用正则表达式匹配,比如:</p>  <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">a</span><span class="selector-attr">[href^="#"]</span>&#123;   <span class="comment">/*以#开头*/</span></span><br><span class="line"><span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="伪类和伪元素"><a href="#伪类和伪元素" class="headerlink" title="伪类和伪元素"></a>伪类和伪元素</h4><p>关于伪类和伪元素的解释可以看<a href="http://swordair.com/origin-and-difference-between-css-pseudo-classes-and-pseudo-elements/" target="_blank" rel="external">这里</a>.</p><p>简单概括一下就是</p><p>比如下面的例子,想要修改列表中某一行的样式,添加class可以实现,所以:nth-child()是伪类.</p><p>再下面想要修改无序列表前的点的样式,正常需要在li标签中添加一个元素来设置,所以:before是一个伪元素.</p><ul><li><p>伪类</p><blockquote><p>CSS 伪类用于向某些选择器添加特殊的效果。</p></blockquote><p>  这里直接截了W3CSchool的图,只是列出了一部分</p><p>  <img src="http://7xr09w.com1.z0.glb.clouddn.com/CSS3%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-02-24%20%E4%B8%8B%E5%8D%888.37.28.png" alt="image"></p><p>  通过一段同样的HTML代码:</p>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ol</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>我是第1行<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>我是第2行<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>我是第3行<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>我是第4行<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>我是第5行<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br></pre></td></tr></table></figure><p>  简单介绍几个常用的伪类:</p><p>  :nth-child()</p>  <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">li</span><span class="selector-pseudo">:nth-child(3)</span>&#123;</span><br><span class="line"><span class="attribute">color</span>: red;</span><br><span class="line"><span class="comment">/*</span><br><span class="line">1. 元素必须是li</span><br><span class="line">2. 从父级里面找同级元素的第x个,但是必须是li元素</span><br><span class="line">*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  效果如下,匹配第3个同级元素<br>  <img src="http://7xr09w.com1.z0.glb.clouddn.com/CSS3%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-02-24%20%E4%B8%8B%E5%8D%888.47.47.png" alt="image"></p><p>  还可以用n来匹配</p>  <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">li</span><span class="selector-pseudo">:nth-child(2n+1)</span>&#123;</span><br><span class="line"><span class="attribute">color</span>: yellow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  匹配所有奇数行的样式.</p></li><li><p>伪元素</p><blockquote><p>CSS 伪元素用于向某些选择器设置特殊效果。</p></blockquote><p>  <img src="http://7xr09w.com1.z0.glb.clouddn.com/CSS3%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-02-24%20%E4%B8%8B%E5%8D%888.37.47.png" alt="image"></p><p>  :before</p>  <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">li</span><span class="selector-pseudo">:before</span>&#123;</span><br><span class="line"><span class="attribute">content</span>: <span class="string">"·"</span>;</span><br><span class="line"><span class="attribute">color</span>: red;</span><br><span class="line"><span class="attribute">display</span>: inline-block;</span><br><span class="line"><span class="attribute">width</span>: <span class="number">20px</span>;</span><br><span class="line"><span class="attribute">height</span>: <span class="number">20px</span>;</span><br><span class="line"><span class="attribute">background-color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  可以自定义列表前的显示样式,效果:</p><p>  <img src="http://7xr09w.com1.z0.glb.clouddn.com/CSS3%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-02-24%20%E4%B8%8B%E5%8D%888.02.43.png" alt="image"></p><p>  通过上面的例子其实可以看出来,伪类和伪元素的最大的区别在于伪类可以通过添加class来实现,伪元素通过添加一个元素来实现.</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;CSS3的组合选择器&quot;&gt;&lt;a href=&quot;#CSS3的组合选择器&quot; class=&quot;headerlink&quot; title=&quot;CSS3的组合选择器&quot;&gt;&lt;/a&gt;CSS3的组合选择器&lt;/h3&gt;&lt;p&gt;在CCS3中增加了一些组合选择器,方便更多条件的查找,jQuery等都可以根据组合选择器来选择元素.&lt;br&gt;
    
    </summary>
    
    
      <category term="html5" scheme="http://yoursite.com/tags/html5/"/>
    
  </entry>
  
  <entry>
    <title>CSS基本样式</title>
    <link href="http://yoursite.com/2016/02/19/CSS%E5%9F%BA%E6%9C%AC%E6%A0%B7%E5%BC%8F/"/>
    <id>http://yoursite.com/2016/02/19/CSS基本样式/</id>
    <published>2016-02-19T05:46:45.000Z</published>
    <updated>2016-05-18T03:53:35.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>CSS:(cascading style sheet)一般称为层叠样式表</strong><br>,一种用来为结构化文档（如HTML文档或XML应用）添加样式（字体、间距和颜色等）的计算机语言.</p><p>网页的读者和作者都可以使用CSS来决定文件的颜色、字体、排版等显示特性,比如Chrome浏览器的<a href="https://userstyles.org/" target="_blank" rel="external">Stylish</a>插件可以自定义网页的css文件,来修改网站样式。CSS最主要的目的是将文件的内容与显示分隔开来。<br><a id="more"></a><br>这有许多好处：</p><ul><li>文件的可读性加强</li><li>文件的结构更加灵活</li><li>作者和读者可以自己决定文件的显示</li><li>文件的结构简化了<br>另外，在HTML中：</li></ul><p>一个整个网站或其中一部分网页的显示信息被集中在一个地方，要改变它们很方便</p><p>不同的读者可以有不同的样式，比如有的读者需要字体比较大</p><p>HTML文件本身的范围变小了，它的结构简单了，它不需要包含显示的信息</p><p>CSS还可以控制其他参数，例如声音（假如浏览器有阅读功能的话）或给视障者用的感受装置。</p><h3 id="几种引入方式"><a href="#几种引入方式" class="headerlink" title="几种引入方式"></a>几种引入方式</h3><ul><li><p>外部引入:</p><p> 在head中可以引入另外一个单独的css文件</p> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"test.css"</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><ul><li><p>一个css文件可以控制多个html页面</p></li><li><p>方便改版和维护</p></li><li><p>有效利用浏览器的缓存,实现加载更快</p></li><li><p>相对于整站来说,代码更少,更加方便于分工合作</p></li><li><p>相对于单页面来说,有垃圾代码,而且link标签中的href会增加服务器的压力</p></li><li><p>整站访问量不是特别大的网页中</p></li></ul></blockquote></li></ul><ul><li><p>头部引用:放在头部的style中</p>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span><span class="css"></span><br><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line"><span class="attribute">color</span>: <span class="number">#999</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><ul><li><p>速度快(相对于网络层面),没有请求压力</p></li><li><p>相对外部引入来说代码更少</p></li><li><p>不宜改版和维护</p></li><li><p>代码很乱,不利于前后台的沟通</p></li><li><p>使用场景:高访问量的网页(首页,活动页)</p></li></ul></blockquote></li></ul><ul><li><p>标签内引用</p>  <figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">div</span> style=<span class="string">"color: blue; "</span>&gt;我是<span class="keyword">div</span>&lt;/<span class="keyword">div</span>&gt;</span><br></pre></td></tr></table></figure><blockquote><p> 1.优先级最高</p><p> 2.多余代码多</p><p> 3.不利于维护</p><p> 使用场景:跟js和后台生成</p></blockquote></li></ul><p> 优先级:外部-头部-标签内</p><p> 范围越小,优先级越高</p><hr><h3 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h3><ul><li><p>标签名选择器</p>  <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line"><span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>class选择器</p>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"###"</span> <span class="attr">class</span>=<span class="string">"red"</span>&gt;</span>超链接<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>  <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.red</span>&#123;</span><br><span class="line"><span class="attribute">color</span>:red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>id选择器</p>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"###"</span> <span class="attr">id</span>=<span class="string">"red"</span>&gt;</span>超链接<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>  <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#red</span>&#123;</span><br><span class="line"> <span class="attribute">color</span>:red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>组合选择器</p><ol><li><p>div标签下的所有a标签的样式,包括嵌套后的a标签(不推荐使* 用)</p>   <figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">div</span>&gt;</span><br><span class="line">  &lt;<span class="keyword">a</span> href=<span class="string">"###"</span>&gt;<span class="keyword">a</span>标签&lt;/<span class="keyword">a</span>&gt;</span><br><span class="line">&lt;/<span class="keyword">div</span>&gt;</span><br></pre></td></tr></table></figure> <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> <span class="selector-tag">a</span>&#123;</span><br><span class="line"><span class="attribute">color</span>:red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>div的下一级a标签有效(仅CSS3支持)</p> <figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">div</span>&gt;</span><br><span class="line"> &lt;<span class="keyword">a</span> href=<span class="string">"###"</span>&gt;<span class="comment">###&lt;/a&gt;</span></span><br><span class="line">&lt;/<span class="keyword">div</span>&gt;</span><br></pre></td></tr></table></figure> <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&gt;<span class="selector-tag">a</span>&#123;</span><br><span class="line"><span class="attribute">color</span>:red;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li><li><p>div标签下a标签class为green的样式</p> <figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">div</span>&gt;</span><br><span class="line">&lt;a href=<span class="string">"###"</span> <span class="built_in">class</span>=<span class="string">"green"</span>&gt;<span class="comment">###&lt;/a&gt;</span></span><br><span class="line">&lt;/<span class="keyword">div</span>&gt;</span><br></pre></td></tr></table></figure> <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> <span class="selector-tag">a</span><span class="selector-class">.green</span>&#123;</span><br><span class="line"><span class="attribute">color</span>:green;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>多个标签,class,id使用同一种样式</p> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>这是p<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>这是div<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"###"</span> <span class="attr">class</span>=<span class="string">"green"</span>&gt;</span>我是a1<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"###"</span> <span class="attr">class</span>=<span class="string">"red"</span> <span class="attr">id</span>=<span class="string">"green"</span>&gt;</span>我是a2<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"###"</span>&gt;</span>我是a3<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"###"</span> <span class="attr">class</span>=<span class="string">"red"</span>&gt;</span>我是a4<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"###"</span>&gt;</span>我是a5<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure> <figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span>,<span class="selector-tag">p</span>,<span class="selector-class">.red</span>,#green&#123;</span><br><span class="line"><span class="attribute">color</span>:red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li></ul><hr><h3 id="常用样式"><a href="#常用样式" class="headerlink" title="常用样式"></a>常用样式</h3><ul><li><p>文字样式</p>  <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span>&#123;</span><br><span class="line"><span class="attribute">font-family</span>:<span class="string">"宋体"</span>;</span><br><span class="line"><span class="attribute">font-size</span>:<span class="number">20px</span>;</span><br><span class="line"><span class="attribute">font-style</span>:normal;</span><br><span class="line">  <span class="comment">/*</span><br><span class="line"> normal  - 文本正常显示</span><br><span class="line">  italic - 文本斜体显示</span><br><span class="line"> oblique - 文本倾斜显示;</span><br><span class="line">  */</span></span><br><span class="line"> <span class="attribute">font-weight</span>:bold;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>文本样式</p>  <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span>&#123;</span><br><span class="line"><span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line"><span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line"><span class="comment">/*边框*/</span></span><br><span class="line"><span class="attribute">border</span>: <span class="number">1px</span> solid red;</span><br><span class="line"><span class="comment">/*行高*/</span></span><br><span class="line"><span class="attribute">line-height</span>: <span class="number">200px</span>;</span><br><span class="line"><span class="comment">/*文本修饰*/</span></span><br><span class="line"><span class="comment">/*下划线*/</span></span><br><span class="line"><span class="attribute">text-decoration</span>: underline;</span><br><span class="line"><span class="comment">/*删除线*/</span></span><br><span class="line"><span class="attribute">text-decoration</span>: line-through;</span><br><span class="line"><span class="comment">/*文本缩进*/</span></span><br><span class="line"><span class="comment">/*浏览器默认一个字16px*/</span></span><br><span class="line"><span class="attribute">text-indent</span>: <span class="number">32px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">a</span>&#123;</span><br><span class="line">  <span class="comment">/*取消a标签的下划线,其实是取消所有样式设置*/</span></span><br><span class="line"><span class="attribute">text-decoration</span>: none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;CSS:(cascading style sheet)一般称为层叠样式表&lt;/strong&gt;&lt;br&gt;,一种用来为结构化文档（如HTML文档或XML应用）添加样式（字体、间距和颜色等）的计算机语言.&lt;/p&gt;
&lt;p&gt;网页的读者和作者都可以使用CSS来决定文件的颜色、字体、排版等显示特性,比如Chrome浏览器的&lt;a href=&quot;https://userstyles.org/&quot;&gt;Stylish&lt;/a&gt;插件可以自定义网页的css文件,来修改网站样式。CSS最主要的目的是将文件的内容与显示分隔开来。&lt;br&gt;
    
    </summary>
    
    
      <category term="html5" scheme="http://yoursite.com/tags/html5/"/>
    
  </entry>
  
  <entry>
    <title>公钥私钥加密</title>
    <link href="http://yoursite.com/2015/12/16/%E5%85%AC%E9%92%A5%E7%A7%81%E9%92%A5%E5%8A%A0%E5%AF%86/"/>
    <id>http://yoursite.com/2015/12/16/公钥私钥加密/</id>
    <published>2015-12-15T16:37:40.000Z</published>
    <updated>2016-05-18T03:53:35.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="公钥私钥"><a href="#公钥私钥" class="headerlink" title="公钥私钥"></a>公钥私钥</h4><p>非对称加密算法:加密的解密使用不同的密钥。<br><a id="more"></a><br>公钥和私钥是成对的，但两者也是相互独立的，即得到其中一个不会危害到另一个的安全。</p><ul><li>公钥可以发给所有人，用来加密，但是只有持有私钥的人才能解密。</li><li>私钥用于给文件数字签名，所有持有公钥的人都可以使用公钥验证。</li><li>数字证书是由CA（certificate authority）证书颁发机构将公钥及对应的信息绑定在一起权威发布的安全证书，从数字证书中可以获取公钥，并且可以确认对应公钥的所有者相关信息。</li></ul><p>一个比较完整的栗子<br> 两个人SA和SB，SA要把消息发给SB，每个人手里都有一对自己的和对方的公钥和私钥:</p><p> 第一种情况：</p><blockquote><p>SA用自己的公钥加密发给SB，SB接收到消息后使用SA的私钥解密获取对应的信息。对于消息本身来说，只要SA的私钥不泄露就不会有问题。</p></blockquote><p>第二种情况：</p><blockquote><ul><li>SA用自己的私钥对密码做数字签名发送给SB，SB收到消息后使用SA的公钥来验证消息是否是SA发出的。</li><li>那么假设SC将SB手上的SA的公钥偷偷替换成了SC自己的公钥，然后用自己的私钥签名给SB发消息，那么SB无法判断出来得到消息是否真得来自于SA。所以如果SA通过证书中心生成自己的安全证书，证书中携带有SA的公钥以及SA的身份信息，这样SB只要得到SA的安全证书就可以验证了，SB通过此证书可以取得SA的公钥，确认消息来自于SA。</li></ul></blockquote><p> 第三种情况：</p><blockquote><ul><li>SA使用自己的私钥对消息做数字签名，之后使用SB的公钥对消息加密。</li><li>SB拿到加密后的密码后使用自己的密钥可以解密，然后用SA的公钥验证。</li></ul></blockquote><!--举个栗子:> 支付宝的订单加密过程,支付宝会给每个商户分配一个私钥,商户用此私钥给订单加密,订单发送给支付宝,支付宝通过自己手里的公钥验证此订单是否被篡改过.常用证书格式--><p>iOS下常用加密证书类型：</p><ul><li>pfx证书：PKCS#12用于公密钥交换的文件格式之一，Microsoft最早提出的专有格式，文件中同时含有公钥和私钥，有密码保护。</li><li>p12证书：PKCS#12用于公密钥交换的文件格式之一，文件中同时含有公钥和私钥，有密码保护。</li><li>cer证书：仅含有公钥，不含密钥，公钥以BASE64进行编码存放。</li><li>pem证书：同cer证书一样，仅含有公钥，公钥以ASCII进行存放。</li></ul><h6 id="OpenSSL命令行方式获取公钥和私钥："><a href="#OpenSSL命令行方式获取公钥和私钥：" class="headerlink" title="OpenSSL命令行方式获取公钥和私钥："></a>OpenSSL命令行方式获取公钥和私钥：</h6><p>从pfx提取密钥信息，并转换为key格式（pfx使用pkcs12模式填充）</p><p>1、提取密钥对（如果pfx证书已加密，会提示输入密码。）</p><blockquote><pre><code>openssl pkcs12 -in 1.pfx -nocerts -nodes -out 1.key</code></pre><p> //如果pfx证书已加密，上面会提示输入密码</p></blockquote><p>2、从密钥对提取私钥</p><blockquote><pre><code>openssl rsa -in  1.key -out 1_pri.key</code></pre></blockquote><p>3、从密钥对提取公钥</p><blockquote><pre><code>openssl rsa -in 1.key -pubout -out 1_pub.key</code></pre><p>那么<br>1_pub.key文件就是公钥。<br>1_pri.key文件是私钥。</p></blockquote><p>2015年12月16日上午12:32 待完善</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;公钥私钥&quot;&gt;&lt;a href=&quot;#公钥私钥&quot; class=&quot;headerlink&quot; title=&quot;公钥私钥&quot;&gt;&lt;/a&gt;公钥私钥&lt;/h4&gt;&lt;p&gt;非对称加密算法:加密的解密使用不同的密钥。&lt;br&gt;
    
    </summary>
    
    
      <category term="iOS安全" scheme="http://yoursite.com/tags/iOS%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
</feed>
