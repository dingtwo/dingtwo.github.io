<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 如何调试RxJS(译) · QQ空间</title><meta name="description" content="如何调试RxJS(译) - Dinger"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.ico"><link rel="stylesheet" href="/css/prontera.css"><link rel="search" type="application/opensearchdescription+xml" href="https://dingjz.top/atom.xml" title="QQ空间"></head><body><header class="feature-header"><nav class="component-nav"><ul><div class="logo-container"><a href="/"><h2 class="title">QQ空间</h2></a></div><a href="/" target="_self" class="li component-nav-item"><p>INDEX</p></a><a href="/archives" target="_self" class="li component-nav-item"><p>ARCHIVES</p></a><ul class="shortcut-icons"><a href="https://github.com/AngryPowman" target="_blank"><img src="/images/github.svg" class="icon"></a><a href="/atom.xml" target="_blank"><img src="/images/rss.svg" class="icon"></a></ul></ul></nav></header><main class="container"><div id="post-container"><div class="post"><article class="post-block"><h1 class="post-title">如何调试RxJS(译)</h1><div class="post-info">May 5, 2017</div><div class="post-content"><p><a href="https://staltz.com/how-to-debug-rxjs-code.html" target="_blank" rel="external">原文How to debug RxJS code</a></p>
<p>开始学习RxJS时通常都会遇到一个共同的问题, 如何调试RxJS.</p>
<p>简短一点的答案是: 你需要大量依赖在纸上画Marble Diagram图并且在代码的operators后添加<code>.do(x =&gt; console.log(x))</code></p>
<p>下面是长答案.<br>一旦你的代码中到处都是Observables并且RxJS订阅了控制流, 传统的断点调试方式就没那么有用了, 你的代码完全使用Observables编码, 断点调试工具对于使用了RxJS库的代码束手无策.</p>
<p>在责怪RxJS的不可调试之前, 我们先从宏观的角度来看看这个问题. 传统的调试是建立在面向过程的编码方式上的, 而不是其他编程泛型. 你的代码越是面向过程, 传统调试越有用. 使用RxJS的代码比普通的面向过程的js代码更加抽象, 使用传统的调试方式通常并不能帮我们真正解决问题. 同样用于调试Promises或者基于回调函数的代码. 与其说Promise不易调试, 不如直接使用专为Promise设计的调试工具, 比如<a href="https://www.youtube.com/watch?v=o9c3U5_8tGY" target="_blank" rel="external">Chrome的Promise开发者工具</a>(已经被移除)</p>
<p>这就是说, 当下主要有3种方式调试RxJS:</p>
<ul>
<li><a href="#first">添加<code>.do(x =&gt; console.log(x))</code>来追踪log</a></li>
<li><a href="#second">画依赖图来跟踪据流</a></li>
<li><a href="#third">画<code>marble diagram</code></a></li>
</ul>
<p>调试的目标是使代码在执行过程中我们有一个清晰的思维模型, 下面的这三种技术能够帮我们实现.</p>
<h2 id="first">追踪log</h2>

<p>这是最基本的方式: 把事件发生时的数据流传递给<code>console.log</code></p>
<p>声明一个Observable变量<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> shortLowerCaseName$ = name$</span><br><span class="line">.map(name =&gt; name.toLowerCase())</span><br><span class="line">.filter(name =&gt; name.length &lt; <span class="number">5</span>)</span><br></pre></td></tr></table></figure></p>
<p>数据有两次变换, 我们可以在两次operators之间插入<code>.do(x =&gt; console.log(x))</code><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> shortLowerCaseName$ = name$</span><br><span class="line">.map(name =&gt; name.toLowerCase())</span><br><span class="line">.do(x =&gt; <span class="built_in">console</span>.log(x))</span><br><span class="line">.filter(name =&gt; name.length &lt; <span class="number">5</span>);</span><br></pre></td></tr></table></figure></p>
<p><code>do</code>就像一次什么都没有做的map操作一样, 上面的代码等价于:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> shortLowerCaseName$ = name$</span><br><span class="line">.map(name =&gt; name.toLowerCase())</span><br><span class="line">.map(x =&gt; &#123;</span><br><span class="line"><span class="built_in">console</span>.log(x);</span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">&#125;)</span><br><span class="line">.filter(name =&gt; name.length &lt; <span class="number">5</span>);</span><br></pre></td></tr></table></figure></p>
<p>和直接订阅<code>shortLowerCaseName$</code>不同<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> shortLowerCaseName$ = name$</span><br><span class="line">.map(name =&gt; name.toLowerCase())</span><br><span class="line">.filter(name =&gt; name.length &lt; <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">shortLowerCaseName$.subscribe(name =&gt; <span class="built_in">console</span>.log(x));</span><br></pre></td></tr></table></figure></p>
<p>因为Observables在订阅之前是不会执行的(类似于generator), 订阅会触发operator的链式执行, 如果在<code>do</code>中使用了<code>log</code>但是没有订阅, <code>console.log</code>永远都不会执行.</p>
<p>所以<code>.do(x =&gt; console.log(x))</code>是一种无侵入的追踪技术, 不会改变代码本身的行为, 只是简单的反应中实际执行过程中的情况, 而订阅是侵入式的, 因为它会向operator链请求数据, 改变代码本身的运行, 特别是在调试.</p>
<p>注意<code>do()</code>也是一个operator: 它会返回一个新的Observable. 如果你只是想简单的用<code>do()</code>替换<code>subscribe()</code>, 没什么卵用, 因为你只能获取一个新的Observable但是并没有拉取数据.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> shortLowerCaseName$ = name$</span><br><span class="line">.map(name =&gt; name.toLowerCase())</span><br><span class="line">.filter(name =&gt; name.length &lt; <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// This console.log will never happen!</span></span><br><span class="line">shortLowerCaseName$.<span class="keyword">do</span>(name =&gt; <span class="built_in">console</span>.log(name));</span><br></pre></td></tr></table></figure>
<p>想要获取<code>do()</code>的输出必须把它放在operator链中并且最后订阅数据流.</p>
<h2 id="second">画依赖图来跟踪数据</h2>

<p>假如有如下的代码:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> shortLowerCaseName$ = name$</span><br><span class="line">.map(name =&gt; name.toLowerCase())</span><br><span class="line">.filter(name =&gt; name.length &lt; <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bmi$ = weight$.combineLatest(height$, (weight, height) =&gt;</span><br><span class="line"><span class="built_in">Math</span>.round(weight / (height * height * <span class="number">0.0001</span>))</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fullInfo$ = shortLowerCaseName$.combineLatest(bmi$);</span><br></pre></td></tr></table></figure>
<p>我们顺着依赖关系(例如: shortLowerCaseName$ 依赖于 name$)可以建立依赖关系图, 如下:</p>
<p><img src="https://staltz.com/img/debugging-dep-graph.png" alt=""></p>
<p>简单分析代码之后我们可以很容易的画出来这个图. 每个圈是一个Observable, 并且每个变量声明<code>var b$ = a$.flatMap(...)</code> 在图上就是一个箭头 <code>a$ --&gt; b$</code></p>
<p>Observable的依赖图应该是我们想到的第一个调试工具来检查代码中是否有bug, 对代码结构来说是非常有用的概括.<br>如果在纸上画出依赖图, 你可以在代码的关键位置添加<code>.do(x =&gt; console.log(x))</code>, 来检查Observable每一次操作的情况. 接下来代码执行时你可以通过依赖图看到数据流是如何传递的.</p>
<p>(冷信号, 每次订阅都从头开始, 没有状态, 热信号是所有的订阅者共享信号的状态)<br>要时刻清楚的意识到依赖图中的Observable也是有冷热的, 例如, $a有两个输出箭头, a$ –&gt; b$ 和 a$ –&gt; c$, a$可能使用了.share()变成了b$和c$的热信号. 尽管有时a$需要是个冷信号, 但是我们应该时刻清楚的判断一个信号到底是冷还是热.</p>
<p>通常依赖图已经足够指出数据流中的哪部分和我们所期望的不一致, 进一步的, 我们可以针对某个Observable放大来看, 使用marble diagram来调试它.</p>
<h2 id="third">画<code>marble diagram</code></h2>

<p>大部分基础的RxJS的操作都有<a href="http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#instance-method-map" target="_blank" rel="external">marble diagrams</a>, marble diagram把一个operator操作的Observable的输入(带点的箭头, 在上面)和输出(带点的箭头, 在下面)用图表示出来, 来解释operator是如何工作的. 因为operator只是一个返回新的Observable的函数, 所以你也可以绘制任何输入一个Observables输出一个Observable的函数.</p>
<p><img src="http://reactivex.io/rxjs/img/map.png" alt=""></p>
<p>如果你不确定某个operator是如何运行的, 在这个operator的前后添加<code>.do(x =&gt; console.log(x))</code>, 然后执行代码, 绘制marble diagram, 然后很快就可以知道这个operator是如何工作了. 使用<a href="http://rxmarbles.com/" target="_blank" rel="external">RxMarbles</a>, 拖动marbles来查看基础的operator是如何创建输出的Observable.</p>
<h2 id="未来"><a href="#未来" class="headerlink" title="未来"></a>未来</h2><p>如介绍中所说, 传统的调试在调试RxJS时并没有多大卵用, 并且你可能已经见过了在RxJS库中巨大的函数调用栈.</p>
<p>在下个版本(现在已经是了)会有大幅改进, 调用栈会浅很多, 来使传统方式调试RxJS代码变的可以忍受. </p>
<p>像Promise得到了专有的调试工具(又没了…), RxJS的Observables也可以有专有的调试工具.<br>注入行为到operator链上的所有的观察者, 来自Netflix公司的Ben Lesh 提到未来计划开发一个基于<code>lift()</code>的RxJS调试工具.</p>
<p>在不远的将来, 我们可能会看到实时渲染的依赖关系图或者实时的marble diagrams. 前者可能是使用静态分析或者使用lift架构.</p>
<p>在RxJS5的单元测试中, 大面积的使用marble diagrams(文本格式), 例如:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">it.asDiagram(<span class="string">'debounce'</span>)(<span class="string">'should debounce events'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">var</span> e1 =   hot(<span class="string">'-a--bc--d---|'</span>);</span><br><span class="line">  <span class="keyword">var</span> e2 =  cold( <span class="string">'--|         '</span>);</span><br><span class="line">  <span class="keyword">var</span> expected = <span class="string">'---a---c--d-|'</span>;</span><br><span class="line">  <span class="keyword">var</span> result = e1.debounce(() =&gt; e2);</span><br><span class="line">  expectObservable(result).toBe(expected);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>这些基于文本的marble diagrams已经有用户在RxJS5中使用. 而且, PNG图也可以自动生成. 上述代码的PNG图如下:</p>
<p><img src="https://staltz.com/img/debounce.png" alt=""></p>
<p>自动静态分析这些marble diagrams是自动渲染的第一步.</p>
<p>RxJS的调试工具依然很薄弱, 但是我们正在付出巨大的努力来获得强大的适合Observables的工具</p>
</div></article></div><div id="disqus_thread"></div></div><script>var disqus_shortname = 'angrypowman';
var disqus_identifier = '2017/05/05/如何调试RxJS-译/';
var disqus_title = '如何调试RxJS(译)';
var disqus_url = 'https://dingjz.top/2017/05/05/如何调试RxJS-译/';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//angrypowman.disqus.com/count.js" async></script></main><footer class="footer-container"><div class="paginator"><a href="/2017/06/13/h5视频播放的坑以及解决方案/" class="prev">PREV</a><a href="/2017/05/05/命令行神器/" class="next">NEXT</a></div><div class="copyright"><p>© 2017 <a href="https://dingjz.top">Dinger</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/AngryPowman/hexo-theme-prontera" target="_blank">hexo-theme-prontera</a>.</p></div></footer><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"angrypowman",'auto');ga('send','pageview');</script></body></html>