<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 关于柯里化以及反柯里化 · QQ空间</title><meta name="description" content="关于柯里化以及反柯里化 - Dinger"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.ico"><link rel="stylesheet" href="/css/prontera.css"><link rel="search" type="application/opensearchdescription+xml" href="http://yoursite.com/atom.xml" title="QQ空间"></head><body><header class="feature-header"><nav class="component-nav"><ul><div class="logo-container"><a href="/"><h2 class="title">QQ空间</h2></a></div><a href="/" target="_self" class="li component-nav-item"><p>INDEX</p></a><a href="/archives" target="_self" class="li component-nav-item"><p>ARCHIVES</p></a><ul class="shortcut-icons"><a href="https://github.com/AngryPowman" target="_blank"><img src="/images/github.svg" class="icon"></a><a href="/atom.xml" target="_blank"><img src="/images/rss.svg" class="icon"></a></ul></ul></nav></header><main class="container"><div id="post-container"><div class="post"><article class="post-block"><h1 class="post-title">关于柯里化以及反柯里化</h1><div class="post-info">Mar 20, 2017</div><div class="post-content"><h2 id="一、柯里化-curring"><a href="#一、柯里化-curring" class="headerlink" title="一、柯里化(curring)"></a>一、柯里化(curring)</h2><p>在<a href="https://zh.wikipedia.org/wiki/%E6%9F%AF%E9%87%8C%E5%8C%96" target="_blank" rel="external">维基百科</a>上的解释是: 把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的新函数的技术。</p>
<a id="more"></a>
<p>柯里化的概念简单来说就是把常见的多参数函数改为分步调用, ,逐步传参, 逐步缩小范围, 简单举例</p>
<p>js的写法<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> result = add(<span class="number">1</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure></p>
<p>这是传统方式的写法, 柯里化之后<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">num1</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">num2</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> num1 + num2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> result = add(<span class="number">1</span>)(<span class="number">2</span>);</span><br></pre></td></tr></table></figure></p>
<p>py的写法</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">inc</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">incx</span><span class="params">(y)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> x+y</span><br><span class="line">    <span class="keyword">return</span> incx</span><br><span class="line"></span><br><span class="line">inc2 = inc(<span class="number">2</span>)</span><br><span class="line">inc5 = inc(<span class="number">5</span>)</span><br><span class="line"><span class="keyword">print</span> inc2(<span class="number">5</span>)</span><br><span class="line"><span class="keyword">print</span> inc5(<span class="number">5</span>)</span><br></pre></td></tr></table></figure>
<p>黑人问号脸, 有什么卵用???<br>换个喵神在<a href="http://swifter.tips/currying/" target="_blank" rel="external">swift tips</a>中举的例子, 翻译成js</p>
<blockquote>
<p>柯里化是一种量产相似方法的好办法, 可以通过柯里化一个方法模板来避免写出很多重复代码, 也方便今后维护<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">greaterThan</span>(<span class="params">comparer</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> num &gt; comparer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> greaterThan10 = greaterThan(<span class="number">10</span>);</span><br><span class="line">greaterThan10(<span class="number">13</span>) <span class="comment">//true</span></span><br><span class="line">greaterThan10(<span class="number">8</span>)  <span class="comment">//false</span></span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>有点工厂模式的味道. </p>
<p>再举一个比较常见, 而且比较重要的例子, bind函数的实现<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;.bind) &#123;</span><br><span class="line">    <span class="built_in">Function</span>.prototype.bind = <span class="function"><span class="keyword">function</span>(<span class="params">context</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> self = <span class="keyword">this</span>, args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> self.apply(context, args.slice(<span class="number">1</span>));    </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>另外关于这个函数还可以换方式写, 考察对arguments, apply/call的理解, 也挺有意思的<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;.bind) &#123;</span><br><span class="line">    <span class="built_in">Function</span>.prototype.bind = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> self = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">var</span> context = [].shift.call(<span class="built_in">arguments</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> self.apply(context, <span class="built_in">arguments</span>);    </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>关于柯里化的具体作用也存在争议, 有其优点也有缺陷, 因此只有用在正确的地方才是生产力的提升(废话), apple在swift2中添加了原生柯里化的支持, 即函数可以这么写<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(num1: Int)</span></span>(num2: <span class="type">Int</span>) -&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> num1 + num2</span><br><span class="line">&#125;</span><br><span class="line">add(<span class="number">1</span>)(<span class="number">2</span>)</span><br></pre></td></tr></table></figure></p>
<p>然而在swift3中又去掉了这种方式, 官方的<a href="https://github.com/apple/swift-evolution/blob/master/proposals/0002-remove-currying.md" target="_blank" rel="external">解释</a>是用处有限, 实现复杂</p>
<blockquote>
<p>(Curried function declaration syntax func <code>foo(x: Int)(y: Int)</code> is of limited usefulness and creates a lot of language and implementation complexity. We should remove it.)</p>
</blockquote>
<h2 id="二、反柯里化-uncurring"><a href="#二、反柯里化-uncurring" class="headerlink" title="二、反柯里化(uncurring)"></a>二、反柯里化(uncurring)</h2><p>反柯里化的作用是，当我们调用某个方法，不用考虑这个对象在被设计时，是否拥有这个方法，只要这个方法适用于它，我们就可以对这个对象使用它。<br>到这里都要提一下<a href="https://zh.wikipedia.org/zh-hans/%E9%B8%AD%E5%AD%90%E7%B1%BB%E5%9E%8B" target="_blank" rel="external">鸭子类型</a>(duck typing)</p>
<blockquote>
<p>“当看到一只鸟走起来像鸭子、游泳起来像鸭子、叫起来也像鸭子，那么这只鸟就可以被称为鸭子。</p>
</blockquote>
<p>第一次看到这个概念的时候先想到的是OC里的id类型, id类型的对象可以接受任何方法, 被当做鸭子来测试, 在js中, 提供了call/apply的接口方便我们用类似的思想解决问题.</p>
<p>在js中有一种奇葩类型, 比如arguments, 这是一个类数组的对象, 其本质是个object, 因此没有数组身上的push/pop之类的方法, 然而在某些时候他也需要这些方法, 比如上面用到的<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[].shift.call(<span class="built_in">arguments</span>);</span><br></pre></td></tr></table></figure></p>
<p>通过call/apply的方式可以方便的让其他类型的对象调用自身没有的方法, 反柯里化的实现<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.uncurrying = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> self = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">Function</span>.prototype.call.apply(self, <span class="built_in">arguments</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//测试</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    length: <span class="number">1</span>,</span><br><span class="line">    <span class="number">0</span>: <span class="string">"a"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> push = [].push.uncurrying();</span><br><span class="line">push(obj, <span class="string">"b"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(obj); <span class="comment">//&#123; '0': 'a', '1': 'b', length: 2 &#125;</span></span><br></pre></td></tr></table></figure></p>
<p>最后的函数调用有种php原生函数的感觉, 把调用方法的对象作为参数传入.</p>
<p>下面这种写法可能更容易理解一些<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.uncurring = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> self = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">var</span> obj = [].shift.call(<span class="built_in">arguments</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        self.apply(obj, <span class="built_in">arguments</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</div></article></div><div id="disqus_thread"></div></div><script>var disqus_shortname = 'angrypowman';
var disqus_identifier = '2017/03/20/关于柯里化以及反柯里化/';
var disqus_title = '关于柯里化以及反柯里化';
var disqus_url = 'http://yoursite.com/2017/03/20/关于柯里化以及反柯里化/';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//angrypowman.disqus.com/count.js" async></script></main><footer class="footer-container"><div class="paginator"><a href="/2017/04/27/评论添加网易云跟帖/" class="prev">上一篇</a><a href="/2016/09/29/linux下安装git遇到的小坑/" class="next">下一篇</a></div><div class="copyright"><p>© 2017 <a href="http://yoursite.com">Dinger</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/AngryPowman/hexo-theme-prontera" target="_blank">hexo-theme-prontera</a>.</p></div></footer><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"angrypowman",'auto');ga('send','pageview');</script></body></html>